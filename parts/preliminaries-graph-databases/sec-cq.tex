\section{Relational Databases}

\subsection{SQL and First-Order Logic}

The most common model of databases is by far that of "relational databases",
in which data is stored in \emph{tables}: an example is depicted
in \Cref{fig:relational-database-cinema}.

\begin{table}
	\centering%
	\input{tikz/intro/relational-database-cinema.tex}
	\caption{
		\AP\label{fig:relational-database-cinema}
		A "relational database" consisting of three tables, representing data
		stored by a cinema. (Replica of \Cref{fig:example-db-as-rel}.)
	}
\end{table}

Formally, a \AP""pointed relational database"" $\tup{\?D, \bar d}$
over a "purely relational signature" $\sigma$
consists of, for each "predicate" $\+R$ of arity $k$ in $\sigma$,
a $k$-ary relation $\+R_{(k)}(\?D)$, as well as a tuple $\bar d$ of elements,
called \emph{constants}.
A \AP""relational database"" is a "pointed relational database" whose tuple is empty.%
\footnote{It is often asked that at least one $\+R_{(k)}(\?D)$ is non-empty.
Whether this condition is imposed does change the theory---for instance the "first-order sentences"
that are valid over all non-empty structures is a strict supset of
those valid over all (possibly empty) structures.
However, this condition is mostly required for historical reasons,
and whether the databases are allowed to be non-empty
will be of little importance for the query languages we will consider.}
A tuple occuring in some relation $\+R_{(k)}(\?D)$ is called a \emph{fact}.
From a practical perspective, relations model the tables,
while each fact corresponds to some row: for 
instance the database of \Cref{fig:relational-database-cinema}
has three relations, twelve facts and no constants.%
\footnote{Many variations on the definition above exists:
for instance the columns of the table are often given a name (called \emph{attribute}),
see "eg" \cite[\S\!\S~3.1--3.2]{AbiteboulHullVianu1995Databases}.
This is usually done to make the syntax of relational algebra easier on the eye,
however this is only syntactic sugar \cite[Proposition~5.1.2]{AbiteboulHullVianu1995Databases}.}

Naturally, each "relational database" yields a "$\sigma$-structure" whose
domain is the set of elements occurring in some fact of the database or as a constant.
This structure has the property that each vertex either belongs to some "hyperedge" or
is a constant: in other words, it has no \AP""isolated vertices"".
This mapping is in fact one-to-one: "relational databases" over $\sigma$
are in bijection with "$\sigma$-structures" with no "isolated vertices".

\begin{hypothesisnotation}
	We identify (pointed) "relational databases" with (pointed) "relational structures"
	with no "isolated vertices".
\end{hypothesisnotation}

As mentioned in \Cref{ch:intro}, from a theoretical perspective,
a very natural way of querying these "structures"
is "via" "first-order logic". Remarkably, it is exactly as expressive 
as the fragment of SQL generated by
\begin{align}
	\phi_{(k)}\; & \mathrel{{:}{:}{=}} \sqlop{SELECT DISTINCT} \textrm{ attribute}_1, \dotsc, \textrm{ attribute}_k\notag\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{FROM } \phi_{(i_1)}, \dotsc, \phi_{(i_n)}\notag\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{WHERE} \textrm{ some condition} \label{eq:sql-fo}\\
	& \;\mid \textrm{some table of arity $k$} \notag\\
	& \;\mid \phi_{(k)} \mathrel{\sqlop{ UNION }} \phi_{(k)}
		\mid \phi_{(k)} \mathrel{\sqlop{ EXCEPT }} \phi_{(k)}
		\mid \phi_{(k)} \mathrel{\sqlop{ INTERSECT }} \phi_{(k)}, \notag
\end{align}
where $i_1 + \dotsc + i_n = k$ and the condition after $\sqlop{WHERE}$
is a conjunction of equalities between attributes.
Dealing with the arity $k \in \N$ is required to ensure "eg" that the union 
is homogeneous---"ie" that all facts in the union have the same arity.%
\footnote{Also, the \textsf{DISTINCT} keyword is only necessary because SQL
has a multiset semantics rather than a set-based semantics…}

\begin{proposition}[Codd's theorem {\cite[\S~4]{Codd1972RelationalCompleteness}}]
	\!\footnote{Codd's theorem actually deals
	with \emph{relational algebra} rather than SQL.
	The equivalence between \emph{relational algebra} and the fragment
	\eqref{eq:sql-fo} of SQL is however straightforward.
	See also \cite[Theorem~5.4.6]{AbiteboulHullVianu1995Databases}.}
	\AP\label{prop:codd-thm}
	"First-order logic" over "$\sigma$-structures" with no "isolated vertices"
	is equally expressive to the SQL fragment defined in \eqref{eq:sql-fo}.
	Moreover, this equivalence is effective.
\end{proposition}

\begin{proof}[Proof sketch]
	\emph{Warning:} dealing with all the subtleties of the proof is actually
	somewhat tedious. Hence, we provide an \emph{informal} proof,
	which prioritizes intuition over formalism.

	\proofcase{From SQL to FO.}
	Expressing a SQL query as a "first-order formula" is intuitive,
	by generalizing the idea given in \Cref{sec:intro-cq}:
	\begin{itemize}
		\item $\sqlop{UNION}$, $\sqlop{EXCEPT}$ AND $\sqlop{INTERSECT}$
			are interpreted as the union, set difference ("ie" $- \land (\neg -)$)
			and intersection;
		\item a table of arity $k$, modelled as a relation $\+R_{(k)}$,
			is encoded as the atomic formula
			\[
				\phi_{(k)}(x_1,\hdots,x_k) \defeq \+R_{(k)}(x_1,\hdots,x_k)
			\]
			with $k$ free variables which are all fresh;
		\item a query
			\begin{align*}
				& \sqlop{SELECT DISTINCT} \textrm{ attribute}_1, \dotsc, \textrm{ attribute}_k \\
				& \sqlop{FROM } \phi^1_{(i_1)}, \dotsc, \phi^n_{(i_n)} \\
				& \sqlop{WHERE } \theta 
			\end{align*}
			is encoded as
			\[
				\psi(y_1,\hdots,y_k) \defeq
				\exists \bar x.\;
				\phi^1_{(i_1)}(x^1_1,\dotsc,x^1_{i_1})
				\land \dotsc \land
				\phi^n_{(i_n)}(x^n_1,\dotsc,x^n_{i_n})
				\land \theta,
			\]
			with $y_1$, $\dotsc$, $y_k$ being the variable associated
			to the attributes---"eg" if $\textrm{attribute}_1$ is the
			third attribute of $\phi^2$, then $y_1 \defeq x^2_3$---
			and $\bar x$ is the tuple of all variables of the form $x^i_j$
			that are distinct from the $y_i$'s.
	\end{itemize}
	
	\proofcase{From FO to SQL.}
	The converse encoding, "ie" from first-order logic to SQL queries,
	is a little more tricky:
	\begin{itemize}
		\item union is encoded with \sqlop{UNION},
			intersection and existential quantification with
			\sqlop{SELECT DISTINCT}-\sqlop{FROM}-\sqlop{WHERE};
		\item we encode negation using \sqlop{EXCEPT} and a SQL query
			that outputs every $k$-tuple of vertices of the "structure"---this query can
			be written as a big union of \sqlop{SELECT DISTINCT}-\sqlop{FROM}
			queries;
		\item lastly, universal quantification can then be obtained
			using the tautology
			\[\forall x.\; \phi(x) \equiv \neg\exists x.\; \neg \phi(x).\qedhere\]
	\end{itemize}
\end{proof}

A crucial ingredient that ensures the correctness of these encodings
is actually the fact that "relational databases" are encoded
as "relational structures" \emph{with no "isolated variables"}.%
\footnote{The restriction of "first-order logic" to
"relational databases" is usually called \emph{relational calculus}.}
Take for instance the "first-order formula"
$\neg \textsc{Room}(x,y)$:
we translated it to the SQL query
\[
	\textrm{All pairs}
	\mathrel{\sqlop{ EXCEPT }}
	(\sqlop{SELECT DISTINCT } x, y \mathrel{\sqlop{ FROM }} \textsc{Room})\; 
\]
where `All pairs' is a query outputting all pairs in the database.
This latter query can actually be expressed as a union of
\sqlop{SELECT DISTINCT}-\sqlop{FROM} queries precisely 
thanks to the lack of "isolated vertices" in
the "structure": for more details, we refer the reader 
to the term ``active domain'' in \cite{AbiteboulHullVianu1995Databases}.%
\footnote{The query $\neg \textsc{Room}(x,y)$ is actually a good example of why there is no built-in
negation in SQL, even though it would not change its expressiveness: it
is actually very hard to image a situation where
knowing that `Xavier Dolan' is not the id of a room with capacity `2025-03-28 14:00'
would be useful…}

The expressiveness of this fragment of SQL however comes to the cost
of computational efficiency.

\begin{proposition}[Folklore]
	Given a "first-order formula" $\phi(\bar x)$, a "relational structure" $\?D$
	with no "isolated vertices", and a tuple $\bar d$, deciding
	if $\bar d \in \semFO{\phi(\bar x)}{\?D}$
	is "PSpace"-complete.
\end{proposition}

\begin{proof}[Proof sketch]
	The upper bound can be proven by considering the naïve algorithm
	that recurses on the formula.
	The lower bound follows from a trivial reduction from
	the "quantified Boolean formula problem".
\end{proof}

Even worth, when turning to the \emph{static analysis} of these queries, 
the problems become undecidable. Given two (semantical) "queries" $\phi$ and $\psi$,
we say that they are "semantically equivalent"---implicitly
over "finite@@struct" "relational databases"---when for every "finite@@struct" "relational databases" $\?D$, we have $\?D \in \phi$ "iff" $\?D \in \phi'$.
This fact is denoted by \AP$\phi \intro*\semequiv \phi'$.

\begin{proposition}[Trakhtenbrot $\ast$ Databases, see "eg" {\cite[Theorem~6.3.1 \& Corollary~6.3.2]{AbiteboulHullVianu1995Databases}}]
	\!\footnote{This result is often incorrectly confused with
	"Trakhtenbrot's theorem", which deals with all "relational structures".
	However, the notion of "semantical equivalence" differs when considered
	over "relational databases" or all "relational structures".}
	\AP\label{prop:Trakhtenbrot-db}
	It is undecidable whether a
	"first-order formula" is satisfiable over finite "relational databases".
	In turn, validity and "semantical equivalence" are also undecidable.
\end{proposition}

In turn, it means that there is no hope to optimize a SQL query from the
fragment \eqref{eq:sql-fo}, in the sense of \Cref{sec:intro-existential}.%

\begin{corollary}[Folklore (but not often mentionned), see "eg"
	{\cite[Remark~5.3]{AdlerWeyer2012TreeWidthFirstOrder}}]
	\label{coro:undecidability-minimization}
	Given a "first-order formula" $\phi$ and $k\in\N$, it is undecidable
	whether $\phi$ is "semantically equivalent" to a "formula@@FO" with at most $k$ variables.
\end{corollary}

\subsection{Conjunctive Queries to the Rescue}

The undecidability results of \Cref{prop:Trakhtenbrot-db,coro:undecidability-minimization},
together with the fact that queries occurring in practice---see \Cref{sec:intro-cq}---are
much simpler than the formulas occurring in the undecidability proofs motivate
the study of well-behaved query fragments.
We will focus on "conjunctive queries", which arise from the grammar
\begin{align}
	\phi_{(k)}\; & \mathrel{{:}{:}{=}} \sqlop{SELECT DISTINCT} \textrm{ attribute}_1, \dotsc, \textrm{ attribute}_k\notag\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{FROM } \phi_{(i_1)}, \dotsc, \phi_{(i_n)}\label{eq:sql-cq}\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{WHERE} \textrm{ some condition} \notag\\
	& \;\mid \textrm{some table of arity $k$} \notag
\end{align}
of SQL, where, once again, $i_1 + \dotsc + i_n = k$ and the condition after $\sqlop{WHERE}$
is a conjunction of equalities between attributes.
From the proof of \Cref{prop:codd-thm} it actually follows that this fragment is exactly
as expressive as the fragment of "first-order logic", restricted to "relational databases",
generated by 
\begin{align}
	\phi \mathrel{{:}{:}{=}} \+R_{(k)}(x_1,\dotsc,x_k) \mid \phi \land \phi \mid \exists x.\; \phi,
	\label{eq:fo-cq}
\end{align}
where $\+R_{(k)}$ ranges over the "signature".

Now observe that, when dealing with the fragment \eqref{eq:fo-cq},
the "first-order formula" $(\exists x.\; \phi(x, \bar y)) \land \psi(\bar z)$
is equivalent to $\exists x'.\; (\phi(x', \bar y) \land \psi(\bar z))$
where $x'$ is any variable that occurs neither in $\bar y$ nor in $\bar z$.
For instance, we have 
\[
	(\exists x.\, \+P(x)) \land (\exists x.\, \exists y.\,\+R(x,y))
	\semequiv
	\exists z.\,\exists x.\, \exists y.\, \+P(z) \land \+R(x,y).
\]
This leads to a simple rewriting system that puts every formula from 
\eqref{eq:fo-cq} in so-called "prenex form".

\begin{proposition}[""Prenex form""]
	\AP\label{prop:prenex-form}
	Every formula from \eqref{eq:fo-cq} can be written in the form
	\begin{align}
		\exists \bar x.\, \bigwedge_{i=1}^n \+R^i_{(k_i)}(y^i_1,\dotsc,y^i_{k_i}).
		\label{eq:prenex-fo}
	\end{align}
\end{proposition}

Translating back the "formulas@@FO" in "prenex form" to 
SQL queries, it implies that the fragment \eqref{eq:sql-cq}
is no more expressive than its induction-free fragment
\begin{align}
	\phi_{(k)}\; & \mathrel{{:}{:}{=}} \sqlop{SELECT DISTINCT} \textrm{ attribute}_1, \dotsc, \textrm{ attribute}_k\notag\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{FROM } \textrm{table}_{(i_1)}, \dotsc, \textrm{table}_{(i_n)}\label{eq:sql-cq-bis}\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{WHERE} \textrm{ some condition}. \notag
\end{align}

Hence, we define a \AP"conjunctive query" to be
any "first-order formula" in "prenex form"---see \Cref{eq:prenex-fo}.
Recall that, as mentioned in \Cref{rk:prelim-formula-tuple},
we assume that "formulas" comes with a tuple of variables,
containing all free variables.
Hence, a $k$-ary \AP""conjunctive query"" over a "purely relational signature" $\sigma$,
or \reintro{CQ} for short, amounts to a finite set
of atomic formulas of the form $\+R_{(k)}(x_1,\hdots,x_k)$,
called ""atoms@@cq"", with $\+R_{(k)} \in \sigma$,
together with tuple of $k$ variables $\bar x$, called ""free variables@@cq""
or ""output variables@@cq"". The set of atoms is denoted conjunctively.
So, an example of "conjunctive query" is
\begin{align*}
	\gamma(\textsf{title}, \textsf{time}) \defeq\; 
	& \textsc{Movies}(\textsf{movie\_id}, \textsf{title}, \textsf{length}, \textsf{director}) \\
	& \land
	\textsc{Projections}(\textsf{movie\_id}, \textsf{room\_id}, \textsf{time}).
\end{align*} 
Semantically, it is interpreted as the "first-order formula" in "prenex form"
in which every variable that is not an "output variable" is quantified existentially,
giving in our case
\begin{align*}
	& \exists \textsf{movie\_id}.\, 
	\exists \textsf{length}.\, 
	\exists \textsf{director}.\,
	\exists \textsf{room\_id}.\, \\
	& \hphantom{\land~} \textsc{Movies}(\textsf{movie\_id}, \textsf{title}, \textsf{length}, \textsf{director}) \\
	& \land
	\textsc{Projections}(\textsf{movie\_id}, \textsf{room\_id}, \textsf{time}).
\end{align*} 

Interestingly, the semantics of "conjunctive queries" can be described using "homomorphisms",
via the theory of \emph{duality}: this was first noticed by Chandra and Merlin in
their seminal 1977 paper \cite{ChandraMerlin1977Implementation}.
\begin{definition}
	The "canonical database" associated to a "conjunctive query"
	\[
		\gamma(\bar x) = \bigwedge_{i=1}^n \+R^i_{(k_i)}(y^i_1,\dotsc,y^i_{k_i})
	\]
	over the "purely relational signature" $\sigma$ is the "pointed relational database"
	over $\sigma$ with tuple $\bar x$ and whose facts are
	$\+R^i_{(k_i)}(y^i_1,\dotsc,y^i_{k_i})$ for $i \in \intInt{1,n}$.
\end{definition}

\begin{marginfigure}
	\centering
	\begin{tikzcd}
		x \rar["b"] \dar["a"] & y \dar["a"] \\
		x' & y'
	\end{tikzcd}
	\caption{\AP\label{fig:prelim-db-ex-db}
	The "canonical database" of $\gamma() \defeq x \atom{a} x' \land x \atom{b} y \land y \atom{a} y'$.}
\end{marginfigure}
Since it is somewhat impractical to graphically depict $k$-ary relations for $k \geq 3$,
and since "signatures" that consist only of "unary predicates" are a degenerate case,
we will often consider examples in which all relations are binary.
We will denote these relations by $\atom{a}$, where $a$ ranges over some alphabet $\A$:
moreover, we will often not take the trouble to precise what alphabet we are using
as any alphabet containing all letters occuring in the example will do.
For instance, the "canonical database" of the "conjunctive query"
\[
	\gamma() \defeq x \atom{a} x' \land x \atom{b} y \land y \atom{a} y'
\]
is the "pointed relational database" of \Cref{fig:prelim-db-ex-db}.

We say that a "conjunctive query" is ""Boolean@@cq"" when it has no "output variables".
In this case, its "canonical database" is not only a "pointed relational database" but
in fact a "relational database".
Naturally, "Boolean queries" are denoted by $\gamma()$.
We will sometimes denote some query (either ""Boolean@@cq"" or not)
by $\gamma$ (with no brackets): this is simply to ease the notations when
no ambiguity can arise---we will often explicitly mention the tuple of "output variables"
when introducing the query, and then simply the notation in a second time.

\begin{proposition}[""Duality""]
	\AP\label{prop:duality}
	Let $\gamma(\bar x)$ be a "conjunctive query",
	and let $\tup{\?G, \bar x}$ denote its "canonical database".%
	\footnote{By convention, we denote the "canonical database" using the Roman
	uppercase associated with the Greek letter used to denote
	the query.}
	For any "pointed relational database" $\tup{\?D, \bar d}$,
	we have
	\[
		\bar d \in \semFO{\gamma(\bar x)}{\?D}
		\qquad\text{"iff"}\qquad
		\tup{\?G, \bar x} \homto \tup{\?D, \bar d}.
	\]
\end{proposition}

\begin{proof}
	This follows from the definition of "homomorphisms" and
	the semantics of "first-order logic".
\end{proof}
\begin{marginfigure}
	\centering
	\begin{tikzpicture}
		\node[vertex] at (0,0) (u) {};
		\node[vertex] at (1,0) (v) {};
		\node[vertex] at (2,0) (w) {};
		\draw[edge] (u) to node[above, midway] {$b$} (v);
		\draw[edge] (v) to node[above, midway] {$a$} (w);
		\draw[edge] (u) to[loop above, out=120, in=60, looseness=8] node[above] {$a$} (u);
		\node[below=2pt of u] {$u$};
		\node[below=2pt of v] {$v$};
		\node[below=2pt of w] {$w$};
	\end{tikzpicture}
	\caption{\AP\label{fig:prelim-db-stupid-ex}
		A "relational database" satisfying the "conjunctive query" of 
		\Cref{fig:prelim-db-ex-db}.
	}
\end{marginfigure}
For instance, consider the "relational database" of \Cref{fig:prelim-db-stupid-ex}.
It satisfies the "Boolean query" 
\[
	\gamma() \defeq x \atom{a} x' \land x \atom{b} y \land y \atom{a} y'
\]
asking if there is a $b$-edge ($x \atom{b} y$) whose extremities
have outgoing $a$-edges ($x \atom{a} x'$ and $y \atom{a} y'$):
indeed, there is a $b$-edge from $u$ to $v$, and both $u$ and $v$
have outgoing $a$-edges. In terms of "duality", this is
witnessed by the "homomorphism" from the
"canonical database" of \Cref{fig:prelim-db-ex-db} to the
"database@@rel" of \Cref{fig:prelim-db-stupid-ex},
that sends $x$ and $x'$ onto $u$, $y$ onto $v$ and $y'$ onto $w$.
As witnessed by this example, the "homomorphism" $\?G \to \?D$ actually has a
natural meaning when thinking about model checking.
For this reason, such a "homomorphism" is also called an "evaluation map"---or even
abusively \emph{homomorphism}---from $\gamma$ to $\?D$.

"Duality" has \emph{many} consequences. First, the following evaluation problem
lies in "NP", as it can be encoded into a "homomorphism problem".
\decisionproblem{""Conjunctive Query Evaluation""}{
	A "signature" $\sigma$,
	a "conjunctive query" $\gamma(\bar x)$ over $\sigma$,
	and a "pointed relational $\sigma$-database" $\tup{\?D, \bar d}$.
}{
	Does $\bar d \in \semFO{\gamma(\bar x)}{\?D}$?
}
For "Boolean conjunctive queries", both tuples are empty, and so
this amounts to asking whether the query is true on the "database@@rel".%
\footnote{Indeed, for "Boolean CQs",
$\semFO{\gamma()}{\?D}$ is either empty (that we interpret as \emph{false}),
or equal to the singleton consisting of the empty tuple (that we interpret as \emph{true}).}
It is fact "NP"-complete \cite[Theorem 7]{ChandraMerlin1977Implementation}.
More importantly, "duality" has the consequence that
"semantical equivalence", as well as the finer notion of "containment",
are decidable for "CQs".

Given two "queries@@sem" $\gamma(\bar x)$ and $\gamma'(\bar x')$,
we say that $\gamma(\bar x)$ is ""contained"" in $\gamma'(\bar x')$
whenever (1) $\bar x$ and $\bar x'$ have the same arity, and (2)
$\semFO{\gamma(\bar x)}{\?D} \subseteq \semFO{\gamma'(\bar x')}{\?D}$
for every "finite@@struct" "relational database" $\?D$. This is denoted by
$\gamma(\bar x) \intro*\contained \gamma'(\bar x')$; the notion
of "containment" is also known as \emph{entailment} or \emph{logical implication}.
Clearly, "semantical equivalence" can be obtained as the symmetric
closure of "containment".

\begin{proposition}
	\!\footnote{In fact, another consequence of "duality" is that
	the quantification over "finite@@struct" "relational databases"
	in the definition of "containment" can be equivalently replaced
	by a quantification over "finite structures", or even over all "structures"!}
	\AP\label{prop:containment-hom}
	Let $\gamma(\bar x)$ and $\gamma'(\bar x')$ be two "conjunctive queries".
	The following are equivalent:
	\begin{enumerate}
		\item $\gamma(\bar x) \intro*\contained \gamma'(\bar x')$;
		\item $\tup{\?G, \bar x} \FOmodels \gamma'(\bar x')$;
		\item $\tup{\?G', \bar x'} \homto \tup{\?G, \bar x}$,
	\end{enumerate}
	where $\tup{\?G, \bar x}$ and $\tup{\?G', \bar x'}$ are the "canonical databases"
	of $\gamma(\bar x)$ and $\gamma'(\bar x')$, respectively.
\end{proposition}

\begin{proof}
	\proofcase{(1) $\Rightarrow$ (2).}
	By "duality", $\tup{\?G, \bar x}$ is a model of $\gamma(\bar x)$,
	and so, since this query is "contained" in $\gamma'(\bar x')$,
	it follows that $\tup{\?G, \bar x} \FOmodels \gamma'(\bar x')$.

	\proofcase{(2) $\Rightarrow$ (3).} By "duality".

	\proofcase{(3) $\Rightarrow$ (1).} Assume that
	$\tup{\?G', \bar x'} \homto \tup{\?G, \bar x}$,
	and let us prove that $\gamma(\bar x) \contained \gamma'(\bar x')$.
	Let $\tup{\?D, \bar d}$ be a "pointed relational database",
	and assume that $\tup{\?D, \bar d} \FOmodels \gamma(\bar x)$.
	By "duality", we get $\tup{\?G, \bar x} \homto \tup{\?D, \bar d}$,
	and by precomposing with any "homomorphism" witnessing
	that $\tup{\?G', \bar x'} \homto \tup{\?G, \bar x}$,
	we get that $\tup{\?G', \bar x} \homto \tup{\?D, \bar d}$.
	Once again, by "duality", this amounts to $\tup{\?D, \bar d} \FOmodels \gamma'(\bar x')$,
	which concludes the proof that $\gamma(\bar x) \contained \gamma'(\bar x')$.
\end{proof}

\begin{corollary}
	\label{coro:prelim-db-containment-cq}
	"Containment" (and hence "semantical equivalence") of "conjunctive queries" is
	decidable, and in fact is "NP"-complete.
\end{corollary}


\subsection{The Preordered Set of Conjunctive Queries}
\label{sec:prelim-db-poset-cq}

\begin{marginfigure}
	\centering
	\includegraphics[width=\linewidth]{fig/escher/bound-of-union.jpg}
	\caption{\href{https://mcescher.com/gallery/most-popular/\#iLightbox[gallery\_image\_1]/23}{\emph{Bond of Union}}, M. C. Escher, \textcopyright~The M.C. Escher Company.}
\end{marginfigure}
"Duality" takes its name from the fact that \Cref{prop:containment-hom} can be simply rephrased as
``the preordered set of "conjunctive queries" over $\sigma$ under
"containment" is \emph{dually isomorphic} to the preordered set of "relational databases"
over $\sigma$ under the homomorphism ordering.'' Symbolically: 
\[
	\tup{\kl[CQ]{\textrm{CQ}_\sigma},\; \contained }
	\isom
	\tup{\kl[relational database]{\textrm{RelDb}_\sigma},\; \cohomto }.
\]
Naturally, to go from "relational databases" to "conjunctive queries",
we associate to any "pointed relational database" $\tup{\?G, \bar g}$
a ""canonical conjunctive query"" $\gamma(\bar g)$ with one "atom"
$\+R_{(k)}(x_1,\hdots,x_k)$ for every "hyperedge" $\tup{x_1,\hdots,x_k} \in \+R_{(k)}(\?G)$.
This map is precisely the inverse of the construction defining "canonical databases".

This dual isomorphism has many consequences: essentially every theory that deals with
"relational databases" can be applied to study "conjunctive queries"!

\begin{corollary}[{of "duality" and \Cref{prop:equiv-core-isomorphic}}]
	Two "conjunctive queries" are "semantically equivalent" "iff"
	the "core" of their "canonical database" are "isomorphic".
\end{corollary}

\paragraph*{Graphical depiction of the preordered set of relational databases.}
Note that for each "conjunctive query" $\gamma(\bar x)$, the class of
"pointed relational databases" $\tup{\?D, \bar d}$ satisfying the query
is \AP""closed under homomorphisms"", "ie"
\[
	\text{if}\quad \tup{\?D, \bar d} \FOmodels \gamma(\bar x)
	\quad\text{and}\quad \tup{\?D, \bar d} \homto \tup{\?D', \bar d'}
	\quad\text{then}\quad \tup{\?D', \bar d'} \FOmodels \gamma(\bar x).
\]
We represent the preordered set of "relational databases" ordered by $\homto$ as follows:
each equivalence class of "homorphically equivalent" "relational databases" is
represented by a single point. In other words, points are in one-to-one correspondence
with "cores". Then, we represent a point $\core{\?G}$ below another point $\core{\?D}$
whenever $\core{\?G} \homto \core{\?D}$.
For "Boolean queries", this ordering%
\footnote{Formally, from the preordering over "relational databases" we obtained a partial
order over the quotient of "relational databases" by the equivalence class induced by $\homto$,
which happens to be the poset of "cores". Hence, we will interchangeably
use to terms \emph{preordering} and \emph{(partial) ordering}.}
admits a unique minimal element, which is the empty database.
For "non-Boolean queries", there is also a minimal "relational database" with
no facts, but that has constants.
Similarly, there is always a unique maximal element: the "database@@rel" with
a unique vertex $x$ and such that $\+R_{(k)}(x,\dotsc,x)$ holds for
every $\+R_{(k)} \in \sigma$, and all constants are interpreted as $x$.
We now prove that this poset has a non-trivial structure, provided that the "signature"
is itself non-trivial.

\begin{proposition}
	\AP\label{prop:poset-reldb}
	Assume that $\sigma$ contains at least one symbol of arity at least 2.
	The poset of "relational databases"
	admits infinite chains, infinite co-chains and infinite antichains.
\end{proposition}

\begin{figure}
	\centering
	\begin{tikzpicture}
		\foreach \i in {0,...,5} {
			\pgfmathtruncatemacro\j{mod(\i, 3)}
			\node[vertex, draw=c\j, fill=c\j, fill opacity=.4] (s\i) at (\i*360/6: 1.2cm) {};
		}
		\foreach \i in {0,...,5} {
			\pgfmathtruncatemacro\ip{mod(\i+1, 6)}
			\draw[edge] (s\i) to (s\ip);
		}

		\foreach \i in {0,1,2} {
			\node[vertex, draw=c\i, fill=c\i, fill opacity=.4] (t\i) at ($(\i*360/3: .9cm)+(5, 0)$) {};
		}
		\foreach \i in {0,1,2} {
			\pgfmathtruncatemacro\ip{mod(\i+1, 3)}
			\draw[edge] (t\i) to (t\ip);
		}
	\end{tikzpicture}
	\caption{\AP\label{fig:prelim-db-cycles} The "graphs@@dir" $\?C_6$
	(left) and $\?C_3$ (right) and a "homomorphism" from the former
	to the latter, described by colour coding.}
\end{figure}
\begin{proof}
	For the sake of simplicity, we assume that we actually have
	a binary predicate: this assumption is "wlog" since we can encode the binary 
	relation used in these constructions into any $k$-ary
	relation provided that $k \geq 2$ by encoding $\+E(x,y)$
	as $\+R_{(k)}(x,y,\dotsc,y)$.

	Clearly, "directed paths" provide an infinite chain
	\[
		\pathGraph{1} \homto \pathGraph{2} \homto \cdots
			\homto \pathGraph{n} \homto \pathGraph{n+1} \homto \cdots.
	\]
	We now let $\?C_n$ ($n\in\Np$) denote the directed cycle with domain $\ZnZ{n}$
	and with an edge from $i$ to $j$ "iff" $i+1 = j$, see \Cref{fig:prelim-db-cycles}.
	It is then routine to check that for $n,m\in\Np$, we have $\?C_n \homto \?C_m$
	"iff" $n$ is a multiple of $m$. In particular,%
	\footnote{In fact, we obtain a \emph{projective system}. We will discuss
	projective limits in \todo{ref conclu}.}
	we have
	\[
		\?C_1 \cohomto \?C_2 \cohomto \?C_4 \cohomto \cdots \cohomto \?C_{2^n} \cohomto \?C_{2^{n+1}} \cohomto \cdots.
	\]
	Finally, $\tup{\?C_p}_{p \text{ prime}}$ is an infinite antichain.
\end{proof}

\begin{figure}
	\centering
	\begin{tikzpicture}[
		font=\footnotesize,
		every node/.style={inner sep=0pt,outer sep=0pt}
	]
		\input{tikz/prelim-databases/generate-lattice.tex}
		\node[above left=2pt of 0 17, color=c0] {$\?C_1$};
		\node[above left=2pt of -1 16, color=c0] {$\?C_2$};
		\node[above left=2pt of -2 15, color=c0] {$\?C_4$};
		\node[above left=2pt of -4 13, color=c0] {\rotatebox{-30}{$\vdots$}};
		\node[above left=2pt of -6 11, color=c0] {$\?C_{2^n}$};
		\node[above left=2pt of -7 10, color=c0] {$\?C_{2^{n+1}}$};
		\node[above left=2pt of -9 8, color=c0] {\rotatebox{-45}{$\vdots$}};

		\node[below left=2pt of 0 -17, color=c2] {$\emptyset$};
		\node[below left=2pt of -1 -16, color=c2] {$\?P_1$};
		\node[below left=2pt of -2 -15, color=c2] {$\?P_2$};
		\node[below left=2pt of -4 -13, color=c2] {\rotatebox{30}{$\vdots$}};
		\node[below left=2pt of -6 -11, color=c2] {$\?P_{n}$};
		\node[below left=2pt of -7 -10, color=c2] {$\?P_{n+1}$};
		\node[below left=2pt of -9 -8, color=c2] {\rotatebox{45}{$\vdots$}};

		\node[circle, fill=white, minimum size=4pt] at (4 -9) {};
		\node[circle, fill=c1, opacity=1, minimum size= 4pt, outer sep=1mm] at (4 -9) {};

		\node[color=c1, align=left, text width=3.8cm, outer sep=1mm] at (3.5, -5) (label-cdb)
			{"\textcolor{c1}{canonical database}@canonical database" $\?G$ of a
			"\textcolor{c1}{Boolean conjunctive query}@Boolean conjunctive query" $\gamma$};
		\draw[draw=c1, semithick] (label-cdb) edge[->,out=90,in=-90] ($(4 -9)+(0, -.1)$);
		\draw[draw=c1, semithick, decorate,decoration={brace,amplitude=5pt,raise=.5em}]
  			(0 17) -- (15 2)
			node[color=c1, midway, above right=5mm, align=left, text width=3.8cm]
				{semantics of $\gamma$};
	\end{tikzpicture}
	\caption{\AP\label{fig:poset-reldb} The poset of "relational databases" over a "signature"
	containing at single binary "predicate", where "homomorphisms" go from bottom to top.
	An infinite chain is represented in red, and an infinite co-chain in blue.
	A large yellow dot represents the "canonical database" of a "conjunctive query",
	while the semantics of this "conjunctive query" is represented with normal-size yellow dots.}
\end{figure}
Based on \Cref{prop:poset-reldb}, we provide an illustration of the ordered set
of "relational databases" in \Cref{fig:poset-reldb}. Notice that, since the semantics
of "conjunctive queries" is closed under "homomorphisms", they are represented by an upper-closed set. Moreover, this set has a unique minimum, corresponding to its "canonical database".
Notice how this representation naturally represents the concept of "duality":
\begin{itemize}
	\item points of the poset ("ie" "relational databases") are in natural
		bijection with upper-closed set that admit a minimum ("ie" "conjunctive queries");
	\item a "conjunctive query" is "contained" in another "iff"
		the "canonical database" of the first is below that of the second
		in \Cref{fig:poset-reldb}.
\end{itemize}

\begin{marginfigure}
	\centering
	\directlua{width = 2.3; height = 1.4}
\input{tikz/prelim-databases/abstract-lattice.lua}%do not indent!!!
	\begin{tikzpicture}[every node/.style={inner sep=0pt,outer sep=0pt},font=\footnotesize]
		\directlua{draw_lattice()}
		\begin{scope}
			\directlua{make_clip()}
			\directlua{draw_cq(.5, -.6, 'c0', 'x')}
			\directlua{draw_cq(.65, .2, 'c2', 'y')}
			\node[below=2pt of x, c0] {$\gamma$};
			\node[below=2pt of y, c2] {$\delta$};
		\end{scope}
	\end{tikzpicture}
	\caption{
		\AP\label{fig:poset-reldb-simple}
		A more abstract view of the poset of "relational databases":
		we represent two "conjunctive queries" $\gamma$ (in red) and $\delta$ (in blue).
		The semantics of each query is represented by a filled diamond,
		and its "canonical database" by a large dot.
	}
\end{marginfigure}
For the sake of simplicity---and compilation time of this document!---,
we abstract the picture of \Cref{fig:poset-reldb} into \Cref{fig:poset-reldb-simple}.

\begin{remark}
	\label{rk:database-vs-structures}
	À propos "relational databases" "vs" "relational structures",
	these posets are actually isomorphic 
	since a "relational structure" is always "homomorphically equivalent"
	to the structure in which we removed "isolated vertices".
\end{remark}

\paragraph*{The Distributive Lattice of Relational Databases.}

\Cref{prop:poset-reldb} shows that the poset of "relational databases" has a somewhat
complex structure, in the sense that it has infinite height, co-height and width.
However, we next show that it has a rich algebraic structure.

\begin{marginfigure}
	\centering
	\begin{tikzcd}[row sep=huge]
		\tup{\?D_1,\bar d_1} &[-4em] &[-4em] \tup{\?D_2,\bar d_2} \\ 
		& \tup{\?D_1,\bar d_1} \prodstruct \tup{\?D_2,\bar d_2}
			\ar[ul, "\projHom{1}" swap] \ar[ur, "\projHom{2}"]
		& \\
		& \tup{\?U, \bar u} \ar[u, "g", dashed]
			\ar[uul, "f_1", bend left] \ar[uur, "f_2" swap, bend right]
		&
	\end{tikzcd}
	\caption{\AP\label{fig:cartesian-product-diagram} Universal property satisfied
	by the "Cartesian product".}
\end{marginfigure}
In light of \Cref{rk:database-vs-structures}, the "Cartesian product"
of two "relational databases" $\tup{\?D_1,\bar d_1}$ and $\tup{\?D_2,\bar d_2}$
whose tuples have the same arity
is well-defined: we consider their product $\tup{\?D_1,\bar d_1} \prodstruct \tup{\?D_2,\bar d_2}$
as "relational structures", and remove all "isolated vertices".
We slightly abuse the notation and still denote this product by $\reintro*\prodstruct$.
It is routine to check that this "Cartesian product" in indeed a Cartesian product in
the categorical sense, "ie" that it satisfies the universal property
that it has "homomorphisms" $\projHom{1}$ and $\projHom{2}$ to both $\tup{\?D_1,\bar d_1}$ and $\tup{\?D_2,\bar d_2}$, and that moreover it is the smallest object satisfying this property,
in the sense that for every "relational database" $\tup{\?U, \bar u}$ with "homomorphisms"
$f_1$ and $f_2$ to $\tup{\?D_1,\bar d_1}$ and $\tup{\?D_2,\bar d_2}$, 
then there exists a unique "homomorphism" $\?G$ from $\tup{\?U, \bar u}$ to
$\tup{\?D_1,\bar d_1} \prodstruct \tup{\?D_2,\bar d_2}$ such that
the diagram of \Cref{fig:cartesian-product-diagram} commutes:
this "homomorphism" $\?G$ is actually $f_1 \times f_2\colon u \mapsto \tup{f_1(u), f_2(u)}$.
Going back to the poset structure, this implies that any pair of points must have an infimum.
\begin{fact}
	Given two finite "relational databases", their "Cartesian product"
	is their greatest lower bound in the poset of "relational databases"
	ordered by $\homto$.
\end{fact}

\begin{marginfigure}
	\centering
	\directlua{width = 2.3; height = 1.4}
\input{tikz/prelim-databases/abstract-lattice.lua}%do not indent!!!
	\begin{tikzpicture}[x=1cm, y=1cm, every node/.style={inner sep=0pt,outer sep=0pt}, font=\footnotesize]
		\directlua{draw_lattice()}
		\begin{scope}
\begin{luacode}
			x0 = 0
			y0 = -.5
			dist = .5
			slope = height/width
			draw_db(x0-dist, y0+dist*slope, 'cBlue', '1')
			draw_db(x0+dist, y0+dist*slope, 'cRed', '2')
			draw_db(x0, y0, 'cYellow', 'prod')
			draw_db(x0, y0+2*dist*slope, 'cPurple', 'union')
\end{luacode}
			\node[left=3.5pt of 1, cBlue] {$\?D_1$};
			\node[right=3.5pt of 2, cRed] {$\?D_2$};
			\node[below=3.5pt of prod, cYellow] {$\?D_1 \prodstruct \?D_2$};
			\node[above=3.5pt of union, cPurple] {$\?D_1 \disunion \?D_2$};
			\draw (prod) edge[->] (1);
			\draw (prod) edge[->] (2);
			\draw (1) edge[->] (union);
			\draw (2) edge[->] (union);
		\end{scope}
	\end{tikzpicture}
	\caption{
		\AP\label{fig:distributive-lattice-rel-db}
		The distributive lattice structure of "relational databases": 
		we represent two "structures", as well as their least upper bound
		and greatest lower bound.
	}
\end{marginfigure}
Similarly, the "disjoint union" satisfies the property dual to \Cref{fig:cartesian-product-diagram}.
\begin{fact}
	Given two finite "relational databases", their "disjoint union"
	is their least upper bound in the poset of "relational databases"
	ordered by $\homto$.
\end{fact}

\begin{figure}
	\centering
	\newrobustcmd{\halfcircle}[2]{
		\begin{scope}[shift=(#1)]
			\fill[#2] (0,0) -- (135:3.4pt) arc (135:315:3.4pt) -- cycle;
			\fill[white] (0,0) -- (135:2.4pt) arc (135:315:2.4pt) -- cycle;
			\fill[#2, fill opacity=.4] (0,0) -- (135:2.4pt) arc (135:315:2.4pt) -- cycle;
		\end{scope}
	}
	\begin{tikzpicture}
		\node[vertex, draw=cGrey, fill=cGrey, fill opacity=.4] (d0) at ($(0*360/2: .7cm)+(-1,0)$) {};
		\node[vertex, draw=cPurple, fill=cPurple, fill opacity=.4] (d1) at ($(1*360/2: .7cm)+(-1,0)$) {};
		\draw[edge, bend right] (d0) to (d1);
		\draw[edge, bend right] (d1) to (d0);

		\foreach \i in {0,1,2} {
			\node[vertex, draw=c\i, fill=c\i, fill opacity=.4] (t\i) at ($(\i*360/3: .9cm)+(7, 0)$) {};
		}
		\foreach \i in {0,1,2} {
			\pgfmathtruncatemacro\ip{mod(\i+1, 3)}
			\draw[edge] (t\i) to (t\ip);
		}

		\foreach \i/\c in {0/cGrey,1/cPurple,2/cGrey,3/cPurple,4/cGrey,5/cPurple} {
			\pgfmathtruncatemacro\im{mod(\i, 3)}
			\node[vertex, draw=c\im, fill=c\im, fill opacity=.4] (s\i) at ($(\i*360/6: 1.2cm)+(3, -2)$) {};
			\halfcircle{s\i}{\c}
		}
		\foreach \i in {0,...,5} {
			\pgfmathtruncatemacro\ip{mod(\i+1, 6)}
			\draw[edge] (s\i) to (s\ip);
		}
		\draw[rounded corners=4pt, dashed, cGrey] (-2.3,-1.2) rectangle (.3,1.2);
		\draw[rounded corners=4pt, dashed, cGrey] (5.8,-1.5) rectangle (8.5,1.5);
		\draw[rounded corners=4pt, dashed, cGrey] (1.3,-3.7) rectangle (4.7,-.3);

		\begin{scope}[yshift=2cm,xshift=2cm]
			\node[vertex, draw=cGrey, fill=cGrey, fill opacity=.4] (2d0) at (0*360/2: .7cm) {};
			\node[vertex, draw=cPurple, fill=cPurple, fill opacity=.4] (2d1) at (1*360/2: .7cm) {};
			\draw[edge, bend right] (2d0) to (2d1);
			\draw[edge, bend right] (2d1) to (2d0);

			\foreach \i in {0,1,2} {
				\node[vertex, draw=c\i, fill=c\i, fill opacity=.4] (2t\i) at ($(\i*360/3: .9cm)+(2, 0)$) {};
			}
			\foreach \i in {0,1,2} {
				\pgfmathtruncatemacro\ip{mod(\i+1, 3)}
				\draw[edge] (2t\i) to (2t\ip);
			}
			\draw[rounded corners=4pt, dashed, cGrey] (-1.3,-1.5) rectangle (3.5,1.5);
		\end{scope}
		\caption{\AP\label{fig:distributive-lattice-rel-db-concrete}
			Two "databases@@rel" (left and right), their "Cartesian product" (below)
			and "disjoint union" (above).
		}
	\end{tikzpicture}
\end{figure}
Put together, these facts imply that the poset of "relational databases" is
actually a bounded lattice, as depicted in \Cref{fig:distributive-lattice-rel-db,fig:distributive-lattice-rel-db-concrete}.
It is moreover distributive
since the isomorphism (and hence "homomorphic equivalence")
\[
	\?A \prodstruct (\?B \disunion \?C) \isom (\?A \prodstruct \?B) \disunion (\?A \prodstruct \?C)
\]
holds for any "databases@@rel" $\?A$, $\?B$ and $\?C$.
Then, by "duality", we get that the poset of "conjunctive queries"
under "containment" is also a distributive lattice!
We shall see that the greatest lower bound and least upper bound
have a natural logical interpretation, and that moreover
this structure of distributive lattice will help us
deal with "CQs": and in particular
solve the "synthesis problem". 


\paragraph*{The Distributive Lattice of Conjunctive Queries.}

Given two "CQs" $\gamma(\bar x)$ and $\delta(\bar y)$,
where $\bar x$ and $\bar y$ have the same arity, we define
their \AP""disjoint conjunction"", denoted by
$\gamma(\bar x) \intro*\disconj \delta(\bar y)$,
to be the "CQs" obtained by taking the "disjoint union" of "atoms" 
of the "CQs" and then identifying the elements of $\bar x$ and $\bar y$ pointwise.
For instance, letting $\gamma(x) \defeq x \atom{a} y$ be the query
asking for all elements with an outgoing $a$-edge,
and $\delta(x) \defeq x \atom{b} y$ be the query
asking for all elements with an outgoing $a$-edge,
then their "disjoint conjunction" $\gamma(x) \disconj \delta(x)$ is
\[
	\alpha(x) \defeq x \atom{a} y \land x \atom{b} y',
\]
which outputs all elements with both an outgoing $a$-edge and an outgoing $b$-edge.%
\footnote{As for "disjoint union", the name "disjoint conjunction" is slightly abusive
but justified by its universal property.}

\begin{fact}
	The "canonical database" of the "disjoint conjunction"
	equals the "disjoint union" of the "canonical databases".
	By "duality", it follows that
	the "disjoint conjunction" is the greatest lower bound
	of two "CQs".%
	\footnote{Careful: "duality" is precisely a \emph{dual} isomorphism,
	"ie" it reverses the order. Hence, a least upper bound ("disjoint union")
	becomes a greatest lower bound ("disjoint conjunction").}
\end{fact}

The other operator (the dual of "Cartesian product")
does not have such a nice intuitive interpretation---however
it does not mean that it will be less useful, on the contrary!
While "conjunctive queries" are not closed under
semantical union---we will see this in \Cref{sec:prelim-db-ucq}---, this operator
acts as the best approximation of it.

\begin{definition}
	We define the \AP""weak union"" \AP$\intro*\weakunion$ of two "CQs"
	with the same number of "output variables"
	as the "canonical CQ" of the "Cartesian produt" of their "canonical databases".
\end{definition}

By construction, it is their greatest upper bound,
in the sense that
$\gamma(\bar x) \contained \gamma(\bar x) \weakunion \delta(\bar y)$,
$\delta(\bar y) \contained \gamma(\bar x) \weakunion \delta(\bar y)$,
and $\gamma(\bar x) \weakunion \delta(\bar y)$ is the smallest "CQ" satisfying this property.

For instance, if $\gamma() \defeq x \atom{a} y$ asks for the existence of an $a$-edge
and $\delta() \defeq x \atom{b} y$ asks for a $b$-edge,
then $\gamma() \weakunion \delta()$ is the empty "CQ",
"ie" the "CQ" that always true: knowing that a "database" contains either an $a$-edge
or a $b$-edge is as good as knowing nothing in terms of "CQ" expressivity.
On the other hand, if $\gamma(x) \defeq x \atom{a} y \atom{b} z$ outputs the source of all 
$ac$-paths and $\delta(x) \defeq x \atom{a} y \atom{c} z$ outputs the source of all $bc$-paths,
then $\gamma(x) \weakunion \delta(x)$ will be "homomorphically equivalent" to
$\upsilon(x) \defeq x \atom{a} y$ which outputs all sources of $a$-edges.

\begin{marginfigure}
	\centering
	\directlua{width = 2.3; height = 1.4}
\input{tikz/prelim-databases/abstract-lattice.lua}%do not indent!!!
	\begin{tikzpicture}[x=1cm, y=1cm, every node/.style={inner sep=0pt,outer sep=0pt}, font=\footnotesize]
		\directlua{draw_lattice()}
		\begin{scope}
\begin{luacode}
			make_clip()
			x0 = 0
			y0 = -.5
			dist = .5
			slope = height/width
			draw_cq(x0, y0, 'cYellow', 'prod')
			draw_cq(x0-dist, y0+dist*slope, 'cBlue', '1')
			draw_cq(x0+dist, y0+dist*slope, 'cRed', '2')
			draw_cq(x0, y0+2*dist*slope, 'cPurple', 'union')
\end{luacode}
			\node[left=3.5pt of 1, cBlue] {$\gamma_1$};
			\node[right=3.5pt of 2, cRed] {$\gamma_2$};
			\node[below=3.5pt of prod, cYellow] {$\gamma_1 \weakunion \gamma_2$};
			\node[above=3.5pt of union, cPurple!50!black] {$\gamma_1 \disconj \gamma_2$};
		\end{scope}
	\end{tikzpicture}
	\caption{
		\AP\label{fig:distributive-lattice-cq}
		The distributive lattice structure of "Boolean conjunctive queries": 
		we represent two "structures", as well as their least upper bound
		and greatest lower bound, and the natural homomorphism they come equipped with
		(projections and canonical embeddings).
	}
\end{marginfigure}
The distributive lattice structure of "conjunctive queries"
is depicted in \Cref{fig:distributive-lattice-cq}. Observe how this
choice of representation makes obvious the fact that
(1) the "disjoint conjunction" of two "CQs" is actually its
conjunction in the semantical sense, but (2)
their "weak union" is strictly bigger than their semantical union,
unless we are in a degenerate case.

We summarize the properties of the two distributive lattices
in \Cref{tab:distributive-lattices}. Note that all notions
occurring in this table, be it the orders or the binary operators,
require the "CQs" to the same number of "output variables",
and the (pointed) "relational databases" to have tuples of the same size,
and so in fact we obtain two lattices for every possible arity/tuple size.
% Note also motivates the somewhat counter-intuitive definition of the
% "disjoint union" for "structures" over "signatures" that are not
% "purely relational@@signature".

\begin{table}
	\centering
	\begin{tabular}{ccc}
		\toprule
		 & "Conjunctive Queries" & "Relational Databases" \\ \midrule
		\multirow{2}{*}{preorder} & \multirow{2}{*}{"containment" $\contained$} & existence of\\
		& & "homomorphisms" $\homto$ \\
		least upper bound & "weak union" $\weakunion$ & "disjoint union" $\disunion$ \\
		greatest lower bound & "disjoint conjunction" $\disconj$ & "Cartesian product" $\prodstruct$ \\ 
		\multirow{2}{*}{greatest element} & \multirow{2}{*}{``true'' (empty "CQ")} & single vertex \\
		& & will all "hyperedges" \\
		\multirow{2}{*}{least element} & single variable & \multirow{2}{*}{empty "database@@rel"}
		\\
		& will all "hyperedges" & \\ \bottomrule
	\end{tabular}
	\caption{
		\AP\label{tab:distributive-lattices}
		The distributive lattices of "conjunctive queries" and "relational databases".
		By "duality", one can go from one lattice to the \emph{opposite} of the other
		by taking "canonical databases" or "canonical conjunctive queries".}
\end{table}

Amongst bounded distributive lattices, the better behaved are
the Boolean algebras, in which every element has a complement.
In our case, this would be an operator $\neg$ "st" for every "database@@rel" $\?D$,
then $\?D \prodstruct {\neg \?D}$ would be "homomorphically equivalent" to
the empty database and $\?D \disunion {\neg \?D}$ to the greatest database,
consisting of a single vertex and all possible "hyperedges" over it.

\begin{proposition}
	The distributive lattice of "databases@@rel" (and hence of
	"conjunctive queries") does not admit complementation.
\end{proposition}

\begin{proof}
	Assume that the "signature" is non-trivial and let $\?D$ be a non-trivial "database@@rel",
	"ie" neither the least nor greatest element of the lattice.
	To ensure that $\?D \disunion {\neg \?D}$ is "homomorphical equivalent"
	to the greatest database, $\neg \?D$ must actually be "homomorphical equivalent" to 
	the greatest database itself,
	but then $\?D \prodstruct {\neg \?D}$ would be non-empty.
	Hence, $\neg \?D$ cannot exist.
\end{proof}

However, "conjunctive queries" still have a bit more structure: we shall
see that they are a Heyting algebra, namely that it is a bounded distributive lattice
with the extra property that for every $\gamma(\bar x)$ and $\delta(\bar y)$,
where $\bar x$ and $\bar y$ have the same arity, then there exists
a greatest element $\chi(\bar z)$ "st"
\[
	\gamma(\bar x) \disconj \chi(\bar y) \contained \delta(\Bar z). 
\]
This greatest element $\chi(\bar z)$ is denoted by \AP$\gamma(\bar x) \intro*\impH \delta(\bar y)$, and is called \emph{implication}.%
\footnote{Heyting algebras were introduced to model intuitionistic logic.
It is not hard to see that the implication $\phi \Rightarrow \psi$
does satisfy the property it is the greatest formula $\chi$
"st" $\phi \land \chi$ entails $\psi$.}

\begin{proposition}
	\!\footnote{The fact that "relational databases" and "conjunctive queries" form
	a bounded distributive lattice is folklore.}
	The bounded distributive lattice of "conjunctive queries" is actually
	a Heyting algebra.
\end{proposition}

\begin{proof}
	We use "duality" to prove this and show that "relational databases" form a ``co-Heyting algebra'',
	in the sense that for any "databases" $\tup{\?G, \bar g}$ and $\tup{\?D, \bar d}$,
	there exists a least element $\tup{\?X, \bar x}$ "st"
	\[
		\tup{\?G, \bar g} \disunion \tup{\?X, \bar x} \cohomto \tup{\?D, \bar d}:
	\]
	$\tup{\?X, \bar x}$ is actually obtained by taking the "disjoint union"
	of all "connected components" of $\tup{\?D, \bar d}$ 
	that cannot be "mapped homomorphically" to $\tup{\?G, \bar g}$.
	The operator $\impH$ can then be explicitly constructed by "duality".
\end{proof}

By construction of $\impH$, it comes naturally equipped with some
form of Currying, in the sense that
\[
	\tup{\?A, \bar a}
	\FOmodels \gamma(\bar x) \impH \delta(\bar y)
	\quad\text{"iff"}\quad
	\tup{\?A, \bar a} \disunion \tup{\?G, \bar x}
	\FOmodels \delta(\bar y),
\]
for any "CQs" $\gamma(\bar x)$ and $\delta(\bar y)$
and any "relational database" $\tup{\?A, \bar a}$,
where $\tup{\?G, \bar x}$ denotes the "canonical database" of $\gamma(\bar x)$.
Similarly, as expected, we have
\[
	\gamma(\bar x) \disconj (\gamma(\bar x) \impH \delta(\bar y))
	\semequiv
	\delta(\bar y).
\]

In \Cref{sec:prelim-db-static-analysis-cq,sec:prelim-db-ucq},
we will apply some of the theory we developed here
to better understand the expressivity of \emph{conjunctive queries}.

\subsection{Static Analysis of Conjunctive Queries}
\label{sec:prelim-db-static-analysis-cq}

\paragraph*{Minimization.}
As we have already seen, the first consequence of "duality" is that
"containment" and "semantical equivalence" are both
decidable, see \Cref{coro:prelim-db-containment-cq}.
We shall now see that the rich theory of "relational structures",
and in particular the concept of "cores" trivializes the question of minimization.

Fix a "relational signature" $\sigma$.
A ""subquery@@CQ"" of $\gamma(\bar x)$ is any "CQ" over $\sigma$
obtained by removing variable and/or atoms from $\gamma$:
to ensure that we still obtain a "CQ" over $\sigma$, "output variables" 
cannot be removed.
In terms of "duality", this amounts to taking the "canonical conjunctive query" of
a "substructure" of the "canonical database".%
\footnote{Careful: if $\gamma'$ is a subquery of $\gamma$, then $\gamma \contained \gamma'$!
The fewer constraints there is, the easier it is to satisfy them…}
We then say that a class $\+C$ of "conjunctive queries" over $\sigma$ is ""monotone@@classCQ""
if for any "CQ" $\gamma(\bar x) \in \+C$, for any "subquery@@CQ" $\gamma'(\bar x)$ of
$\gamma(\bar x)$, we must have $\gamma'(\bar x) \in \+C$.
"Monotone classes of CQs" naturally model the notion of ``simplicity'', in the sense that
a "CQ" is ``simple'' "wrt" $\+C$ whenever it belongs to $\+C$. The "monotonicity@@classCQ"
assumption precisely assures that the class formalizes an idea of ``simplicity''
and not ``the "CQ" has exactly fourteen atoms, two ternary "hyperedges", three legs,
a moustache and a mustard watch.''
Typical examples of "monotone classes of CQs" include:
\begin{itemize}
	\item "CQs" with at most $k \in \N$ "atoms",
	\item "CQs" with at most $k$ variables,
	\item "CQs" of "tree-width" at most $k$ (defined in \Cref{sec:prelim-db-tw}),
	\item "CQs" of "path-width" at most $k$,
	\item "CQs" in which all "cliques" are of size at most $k$, etc.
\end{itemize}

We define the ""core@@CQ"" of a "conjunctive query", still denoted by $\intro*\coreCQ{-}$,
to be the "canonical conjunctive query" of the "core" of its "canonical database".
\begin{proposition}
	\AP\label{prop:minimization-CQ}
	Let $\gamma(\bar x)$ be a "conjunctive query" and $\+C$ be
	a "monotone class of CQs". Then $\gamma(\bar x)$ is "semantically equivalent"
	to a "CQ" in $\+C$ if, and only if, its "core@@CQ" $\coreCQ{\gamma}(\bar x)$
	belongs to $\+C$.
\end{proposition}

\begin{proof}
	This follows from \Cref{prop:equiv-core-isomorphic}
	and the fact that the "core" of a "structure" is always
	a "substructure" of it.
\end{proof}

Not only does this imply that we can solve the $\+C$-minimization problem,
but actually that all these problems can be solved simultaneously,
in the sense that if a solution exists to each problem, then a common solution exists!

\decisionproblem{""CQ minimization problem over $\+C$""}{
	A "conjunctive query".
}{
	Is it "semantically equivalent" to a "CQ" of $\+C$?
}

\begin{corollary}
	\label{coro:decision-minimization-cq}
	For each "monotone class of CQs" $\+C$, assumed to be described as an oracle,
	the ""CQ minimization problem over $\+C$"" is "NP".
	Furthermore, it is "NP"-hard for some classes $\+C$.
\end{corollary}

\begin{proof}
	\proofcase{Upper bound.}
	A naïve algorithm would be to first compute the "core", and using the oracle
	to test if it belongs to $\+C$.
	However, computing the "core" is not in "NP": intuitively,
	we first need to guess a substructure that is "homomorphically equivalent"
	to the whole---which is "NP"---,
	and then check that no strictly smaller structure satisfies the property---which is "coNP".%
	\footnote{In fact, deciding if a "structure" is a "core" is actually
	"coNP"-complete, even for undirected graphs, \cite[Theorem~7]{HellNesetril1992Core}.}
	So, let not be naïve! We start with a "conjunctive query"
	$\gamma(\bar x)$, guess a "subquery" $\gamma'(\bar x)$,
	and then check if (1)%
	\footnote{In fact $\gamma \contained \gamma'$ always holds so
	it suffices to check that $\gamma' \contained \gamma'$.}
	$\gamma'(\bar x) \semequiv \gamma(\bar)$ and
	if (2) $\gamma'(\bar x) \in \+C$.
	The algorithm is clearly in "NP", and moreover it is correct
	by \Cref{prop:equiv-core-isomorphic} and monotonicity.

	\proofcase{Lower bound.} We prove that the minimization problem
	is "NP"-hard for the class $\+C$ of "conjunctive queries" with
	at most $3$ variables.
	In fact, by "duality", we rather prove that the problem
	of, given a "structure", deciding if it is "homomorphically equivalent"
	to a "structure" with at most $3$ vertices is "NP"-hard.
	We reduce "$3$-colourability" to this latter problem.
	Given an instance $\?G$ of "$3$-colourability", we reduce
	it to:
	\begin{itemize}
		\item $\?G \disunion \clique{3}$ if $\?G$ does not contain any self-loop;
		\item any negative instance otherwise, "eg" $\clique{4}$.
	\end{itemize}
	If $\?G$ is "$3$-colourable", then it has no "self-loop"
	and moreover $\?G \homto \clique{3} \homto \clique{3}$
	and hence $\?G \disunion \marked{\clique{3}} \homto \clique{3}$, 
	from which we get that $\?G \disunion \clique{3} \semequiv \clique{3}$,
	and hence $\?G \disunion \clique{3}$ is "semantically equivalent" to a "structure"
	with at most $3$ vertices.
	Conversely, assume that the right-hand side of the reduction is "semantically equivalent" to a 
	"structure" with at most $3$ vertices. Then $\?G$ does not contain any self-loop
	and moreover, we get that $\?G \disunion \clique{3}$ is "homomorphically equivalent"
	to a structure with 3 vertices.
	In particular, we get a "homomorphism" from $\?G$ to a structure with 3 vertices,
	and from the assumption that $\?G$ does not contain any self-loop,
	we actually get a "homomorphism" from $\?G$ to $\clique{3}$.
	This concludes the reduction.%
	\footnote{The trick used for the lower bound, 
	namely that of reducing a "homomorphism"/"containment" problem
	to a minimization problem "via" a "disjoint union", will be used in a
	much trickier way in \Cref{ch:minimization-CRPQ}
	to prove "ExpSpace" lower bounds on the "minimization problem for CRPQs", 
	see \label{sec:minimization-lowerbounds,apdx-sec:lowerbound-variables}.}
\end{proof}

\begin{marginfigure}
	\centering
	\directlua{width = 2.3; height = 1.4}
\input{tikz/prelim-databases/abstract-lattice.lua}%do not indent!!!
	\begin{tikzpicture}[x=1cm, y=1cm, every node/.style={inner sep=0pt,outer sep=0pt}, font=\footnotesize]
		\directlua{draw_lattice()}
		\begin{scope}
\begin{luacode}
			make_clip()
			x0 = 0
			y0 = -.5
			dist = .5
			slope = height/width
			draw_cq(x0+.1, y0-.2, 'cGrey', 'cq')
			draw_db(x0-dist, y0+dist*slope, 'cBlue', 'p1')
			draw_db(x0+dist, y0+dist*slope, 'cBlue', 'p2')
			draw_db(x0-1.5, y0+.5, 'cRed', 'n1')
			draw_db(x0-.3, y0-.2, 'cRed', 'n2')
			draw_db(x0+.67, y0-.4, 'cRed', 'n3')
\end{luacode}
			\node[above=3.5pt of p1, cBlue] {$\?D^+_1$};
			\node[above=3.5pt of p2, cBlue] {$\?D^+_2$};
			\node[below=3.5pt of cq, cGrey!70!black] {$\gamma$};
			\node[below=3.5pt of n1, cRed] {$\?D^-_1$};
			\node[below=3.5pt of n2, cRed] {$\?D^-_2$};
			\node[above=3.5pt of n3, cRed] {$\?D^-_3$};
		\end{scope}
	\end{tikzpicture}
	\caption{
		\AP\label{fig:prelim-db-ex-synthesis}
		An instance of the "synthesis problem for CQs", as well as one valid
		solution for this instance.
	}
\end{marginfigure}
We now turn to the "synthesis problem", also called \emph{passive learning},
\emph{reverse engineering}. The idea behind the problem is to infer a
"query@@sem" from examples: these examples take the form
of models, taking the form of "pointed relational databases", together
with the knowledge of whether this model should be part of the "query@@sem"
(\emph{positive examples}) or not (\emph{negative examples}),
see \Cref{fig:prelim-db-ex-synthesis}.%
\footnote{For the sake of readability, we use the notations
for "Boolean queries" and non-"pointed databases@@rel".
However, all results extend trivially to the non-Boolean case.}

\decisionproblem{""Synthesis Problem for CQs""}{
	Integers $n,p\in \Np$, and
	"pointed relational databases"
	$\?D^+_1$, $\dotsc$, $\?D^+_p$, 
	$\?D^-_1$, $\dotsc$, $\?D^-_n$.
}{
	Is there a "conjunctive query" $\gamma$ "st"
	$\?D^+_i \FOmodels \gamma$ for all $i\in \intInt{1,p}$
	and $\?D^-_j \notFOmodels \gamma$ for all $j\in \intInt{1,n}$?
}

\begin{proposition}
	\label{prop:algo-synthesis-cq}
	The "synthesis problem for CQs" is "coNExp".
\end{proposition}

\begin{proof}
	We denote by $\delta^+_1$, $\dotsc$, $\delta^+_p$ the "canonical conjunctive queries"
	of $\?D^+_1$, $\dotsc$, $\?D^+_p$.
	We now consider their "weak union"
	\[
		\upsilon \defeq \delta^+_1 \weakunion \cdots \weakunion \delta^+_p.
	\]
	We then test for each $j\in \intInt{1,n}$ if 
	$\?D^-_j \notFOmodels \upsilon$: this will be
	the output of our algorithm!
	
	First, each test $\?D^-_j \notFOmodels \upsilon$
	can be done in "coNP" in the size of $\?D^-_j$ and of
	$\upsilon$. Since the size of $\upsilon$ is the product of
	the sizes of the $\delta^+_i$'s, it is exponential,
	and hence we obtain a "coNExp" algorithm.
	Then, we prove---or rather notice---its correctness: by construction,
	the "weak union" is the least upper bound of "CQs",
	see \Cref{fig:ex-synthesis-cq-negative}! \emph{Voilà.}
\end{proof}
\begin{figure}
	\centering
	\directlua{width = 4; height = 2.67}
\input{tikz/prelim-databases/abstract-lattice.lua}%do not indent!!!
\begin{tikzpicture}[x=1cm, y=1cm, every node/.style={inner sep=0pt,outer sep=0pt}, font=\small]
	\directlua{draw_lattice()}
	\begin{scope}
\begin{luacode}
		make_clip()
		x0 = -1.33
		y0 = -0.67
		dist1 = 0.5
		dist2 = 1.0
		slope = height/width
		draw_cq(x0+dist2, y0-dist2*slope, 'cGrey', 'union')
		draw_cq(x0-dist1, y0+dist1*slope, 'cBlue', 'p1')
		draw_cq(x0+dist1, y0+dist1*slope, 'cBlue', 'p2')
		-- position of union of p1 and p2 : (x0, y0)
		draw_cq(x0+2*dist2, y0, 'cBlue', 'p3')
		draw_db(x0+dist2-0.2, y0-dist2*slope+0.5, 'cRed', 'n1')
		draw_db(x0+dist2+1.0, y0-dist2*slope-0.2, 'cRed', 'n2')
\end{luacode}
		\node[left=6pt of p1, cBlue] {$\delta^+_1$};
		\node[right=6pt of p2, cBlue] {$\delta^+_2$};
		\node[right=6pt of p3, cBlue] {$\delta^+_3$};
		\node[below=6pt of union, cDarkGrey] {$\upsilon$};
		\node[right=6pt of n1, cRed] {$\?D^-_1$};
		\node[right=6pt of n2, cRed] {$\?D^-_2$};
	\end{scope}
\end{tikzpicture}
	\caption{
		\AP\label{fig:ex-synthesis-cq-negative}
		A negative instance of the "synthesis problem" and the construction
		done in the proof of \Cref{prop:algo-synthesis-cq}.
	}
\end{figure}

In fact there is a matching lower-bound, even if the "signature" is fixed,
but the  proof is far from trivial.
Willard proved the "coNExp"-hardness in
\cite[Theorem~3]{Willard2010Testing} when the "signature" is part of the input%
\footnote{The result is actually phrased for "constraint satisfaction problems".},
and ten Cate and Dalmau proved the same lower bound
for some fixed "signature" \cite[Theorem~2]{tenCateDalmau2015Product}.%
\footnote{They refer to the "synthesis problem@@CQ" as the ``CQ-definability problem''.}
In both cases, the reduction is from an exponential tiling problem.

\paragraph*{Active learning.}
Active learning, "aka" Angluin-style learning is a setting where
two players interact (\emph{a priori} adversarially): \emph{Student} tries
to lean a "query@@sem" that only \emph{Teacher} knows. To achieve this,
they can ask two kinds of questions.\footnote{``Questions'' are usually called 
``query'' but we avoid this terminology here for obvious reasons.}
\begin{itemize}
	\item Membership questions: they provide a model and asks if it satisfies the "query@@sem";
	\item Equivalence questions: they provide a "query@@sem" and ask Teacher if
		it is "semantically equivalent" to theirs; if yes, the game stops, otherwise
		Teachers provides a counter-example in the form of a model satisfying
		one "query@@sem" but not the other.
\end{itemize}
Of course, Student always has a winning strary: enumerate all queries
and ask for equivalence… The difficult and hence interesting question
is that of \emph{efficient} learning.

Ten Cate, Dalmau and Kolaitis proved that 
the class of all "conjunctive queries" could be
learned with polynomially many questions \cite[Theorem~A]{tenCateDalmauKolaitis2013Learning},
but not with polynomially many questions of a given kind provided
that the "signature" is non-trivial \cite[Theorem~B]{tenCateDalmauKolaitis2013Learning}---"ie"
both kinds of questions are necessary to be able to learn efficiently!
By relying on the distributive lattice structure of "relational databases",
ten Cate and Dalmau then exhibited a subclass of "conjunctive queries",
known as ``$c$-acylic'', that can be learned with
polynomially many membership queries
and no equivalence query \cite[Theorem~5.2]{tenCateDalmau2021ActiveLearning}.


\subsection{Conjunctive Queries of Small Tree-Width}
\AP\label{sec:prelim-db-tw}

Recall that, by "duality", "conjunctive query evaluation" is "NP"-complete:
this begs the question of finding classes of "CQs" with faster evaluation.
We will see that queries whose underlying structure looks like
a tree---formally, queries of bounded "tree-width"---can be "evaluated" in polynomial time.

\paragraph*{Tree-Width.}
\AP "Tree-width" is a measure of how much a
graph differs from a tree---the notion was introduced and rediscovered
numerous times in the 1970 and 1980s; however the first paper
that seems to make a substantial connection between "tree-width" and tractability
seems to be the work of Arnborg and Proskurowski~\cite{ArnborgProskurowski1989LinearTreewidth}.
For a gentle but thorough introduction to "tree-width", we also refer the reader to
\cite[\S~3.6]{NesetrilPOM2012Prolegomena}.

Formally, a \AP""tree decomposition"" of an "undirected graph" $\?G$ is a
pair $\tup{\?T, \intro*\bagmap}$ where $\?T$ is a tree and $\bagmap: \vertex{\?T} \to \pset{\vertex{\?G}}$ is a function that associates to each node of $\?T$, called \AP""bag"",
a set of vertices of $\?G$. When $x \in \bagmap(b)$ we shall say that the "bag"
$b \in \vertex{\?T}$ \AP""contains@@tw"" vertex $v$. Further, it must satisfy the following three properties:
\begin{itemize}
    \item each vertex $v$ of $\?G$ is "contained@@tw" in at least one "bag" of $\?T$,
    \item for each edge $\{u,v\}$ of $\?G$, there is at least one "bag" of $\?T$
        that "contains@@tw" both $u$ and $v$, and 
    \item for every vertex $v$ of $\?G$, the set of bags of $\?T$ "containing@@tw" $v$ is a 
        connected subset of $\vertex{\?T}$.
\end{itemize}

\begin{figure}
	\centering
	\hfill
	\subfloat[``Full'' representation of $\tup{\?T, \bagmap}$.]{%
		\AP\label{fig:ex-tree-dec-full}
		\includegraphics[scale=.65]{fig/semantic-tw/ex-tree-dec-full.pdf}%
	}
	\hfill
	\subfloat[``Concise'' representation of $\tup{\?T, \bagmap}$]{%
		\AP\label{fig:ex-tree-dec-concise}
		\hspace{.5cm}
		\includegraphics[scale=1.3]{fig/semantic-tw/ex-tree-dec-concise.pdf}
		\hspace{.5cm}
	}
	\hfill
	\caption{
		\AP\label{fig:ex-tree-dec}
		Two different representations of the same "tree decomposition" $\tup{\?T, \bagmap}$ of a 
		"directed graph" $\?G$ with six 
		vertices. The underlying tree is a path with four nodes and each "bag" contains 3 
		vertices---hence the "decomposition@tree decomposition" has "width" 2.
	}
\end{figure}
We give an example of "tree decomposition" in \Cref{fig:ex-tree-dec}:
\begin{itemize}
	\item In \Cref{fig:ex-tree-dec-full}, we give the ``full'' representation of
	the "decomposition@tree decomposition": we draw $\?T$,
	and inside each of the four "bags" $b$ of $\?T$
	we represent a copy of $\?G$. Nodes of $\?G$ belonging to $b$ are highlighted, while the others are dimmed. Sometimes, we will only write the
	name of the nodes contained in the "bag", instead of drawing the graph.
	\item In \Cref{fig:ex-tree-dec-concise}, we give a ``concise'' representation:
	we draw over $\?G$ a coloured shape for each "bag" of $\?T$. This representation is ambiguous---the structure of $\?T$ is not made explicit---and will only be used for
	the most simple cases.
\end{itemize}

The \AP""width"" of a "tree decomposition" $\tup{\?T, \bagmap}$ is the maximum size of a "bag" minus one, "ie" $\max{|\bagmap(b)|-1 \mid b\in T}$.
The \AP""tree-width"" of $\?G$ is the minimum of the "width" of all "tree decompositions" of $\?G$. 
The notion can be directly generalized to arbitrary "relational structures":
instead of asking that every edge $\{u,v\}$ is contained in some "bag",
we required that for every "hyperedge" $\tup{x_1,\dotsc,x_k}$,
there exists a "bag" than contains all $x_i$'s.
The \reintro{tree-width} of a "CQ" is naturally defined as
the "tree-width" of its "canonical database".
The "undirected graphs" of "tree-width" at most $1$ are exactly
the forests, "ie" the "disjoint unions" of trees.
On the other hand, the "graph@@dir" of \Cref{fig:ex-tree-dec} has "tree-width" $2$.

\begin{proposition}[{\cite[Theorem~3]{ChekuriRajaraman2000Containment}}]
	\!\footnote{Theorem 3 talks about query "containment" of "CQs", which is in fact equivalent
	to the "evaluation problem" for "CQs". Moreover, the theorem deals with ``query width'',
	but this parameter is equivalent up to a multiplicative constant to the "tree-width"
	\cite[Lemma~2]{ChekuriRajaraman2000Containment} assuming that the "signature" is fixed.} 
	\footnote{An equivalent result was in fact proven a decade ealier
	by Freuder \cite[Theorem~3]{Freuder1990Complexity} using the
	vocabulary of "constraint satisfaction problems".}
	\AP\label{prop:eval-CQ-bounded-tw}
	For any fixed "signature" $\sigma$,
	for every $k\in\N$, "conjunctive query evaluation" can
	be solved in polynomial time when restricted to "CQs" of
	"tree-width" at most $k$.
\end{proposition}

\Cref{prop:eval-CQ-bounded-tw}, as most algorithms on structures of
"bounded tree-width" actually relies on the ability to compute
a "tree decomposition".
\begin{proposition}[{Bodlaender's algorithm \cite[Theorem~1.1]{Bodlaender1996Treewidth}}]
	\!\footnote{The fact that $k$ is fixed is crucial: if it is also
	part of the input, the problem become "NP"-complete
	\cite[Theorem~3.3]{ArnborgCorneilProskurowski1987Complexity}}
	\label{prop:bodlaender}
	For every \emph{fixed} $k\in\Np$, there is a linear-time algorithm
	which takes as input a "finite structure" and decides
	if it has "tree-width" at most $k$, in which case it also
	outputs a witness of the form of a "tree decomposition" of "width" at most $k$. 
\end{proposition}

\begin{proof}[Proof sketch of {\Cref{prop:eval-CQ-bounded-tw}}]
	We are given as input a "CQ" $\gamma(\bar x)$ of "tree-width" at most $k$,
	and a "pointed relational database" $\tup{\?D,\bar d}$, and need
	to decide if $\tup{\?D, \bar d} \FOmodels \gamma(\bar x)$.
	"Wlog", using Bodlaender's algorithm (\Cref{prop:bodlaender}),
	we assume that we also have a "tree decomposition" $\tup{\?T,\bagmap}$
	of the "canonical database" $\tup{\?G, \bar x}$ of $\gamma(\bar x)$.

	We do a bottom-up algorithm on the tree $\?T$,
	which maintains a set $\+H$ of partial "homomorphisms" from
	$\tup{\?G, \bar x}$ to $\tup{\?D, \bar d}$.
	In light of \Cref{fig:ex-tree-dec-full}, the idea is to compute
	for each "bag" where the "variables" it contains could be mapped
	on the "databases".
	Formally, we want this procedure
	to satisfy the following invariant:
	when dealing with "bag" $b$, a partial "homomorphism"
	$f\colon \tup{\?G, \bar x} \pto \tup{\?D, \bar d}$ belongs to $\+H_b$ if, and only if,
	\begin{itemize}
		\item the "domain" of $f$ is $\bagmap(b)$, and
		\item $f$ can be extended into a partial "homomorphism"
			$\tilde f\colon \tup{\?G, \bar x} \pto \tup{\?D, \bar d}$
			defined exactly on the union of $\bagmap(b')$ where $b'$ ranges
			over vertices that are bellow $b$ in the tree $\?T$.
	\end{itemize}
	For leaves $b$, the procedure is easy: we enumerate every possible map
	from $\bagmap(b)$ to $\?D$, and only keep those that define a 
	partial "homomorphism" $\tup{\?G, \bar x} \pto \tup{\?D, \bar d}$: this
	yields a set $\+H_b$ of partial "homomorphisms".
	Then, when dealing with a node $b$ whose children are $b_1,\hdots,b_k$,
	again we enumerate every possible map $f$
	from $\bagmap(b)$ to $\?D$, but then only keep those that
	(1) define a partial "homomorphism" $\tup{\?G, \bar x} \pto \tup{\?D, \bar d}$,
	and (2) agree with the children "bags", in the sense that there must exist
	partial "homomorphisms" $f_1 \in \+H_{b_1}$, $\dotsc$, $f_k \in \+H_{b_k}$
	"st" $f$ and $f_i$ agree on their common vertices,
	"ie" $\restr{f}{\bagmap(b)\cap \bagmap(b_i)} = \restr{f_i}{\bagmap(b)\cap \bagmap(b_i)}$
	for all $i \in \lBrack 1,k\rBrack$.
	
	The correctness of this procedure follows from the assumption that,
	in a "tree decomposition", the set of "bags" "containing@@bag" any node
	must be a connected subset: in some sense this is what allows us to make
	consistent choices.
	Then, to decide if $\tup{\?D, \bar d} \FOmodels \gamma(\bar x)$,
	we check if the set of partial "homomorphisms" associated to the root
	is non-empty. If so, since every vertex must appear in some "bag",
	the invariant yields the existence of a "homomorphism" 
	from $\tup{\?G, \bar x}$ to $\tup{\?D, \bar d}$.
	Otherwise, there is no such "homomorphism". Correctness follows by "duality".

	Lastly, concerning the complexity, observe that the "tree decomposition"
	has "width" at most $k$, so there at most
	$|D|^{k+1}$ maps from any fixed "bag" to $\?D$: we can enumerate them all
	in polynomial time since $k$ is fixed! 
	To compute the partial "homomorphisms" $f$ that agree with
	some partial "homomorphisms" from $\+H_{b_1}$, $\dotsc$, $\+H_{b_k}$,
	we can first sort each table $\+H_{b_i}$ according to their value on $\bagmap(b)$,
	and then use a dichotomy search. Sorting can be done
	in $\+O(|D|^{k+1}\log(|D|^{k+1})) = \+O(|D|^{k+1}\log(|D|))$,
	and the dichotomy search---one for each partial "homomorphisms" that is a candidate
	for $\+H_b$---runs in $\+O(\log(|D|^{k+1})) = \+O(\log(|D|))$.
	Overall, we get an algorithm that runs in time
	\[
		\+O(|T|\cdot |D|^{k+1}) = \+O(|\vars{\gamma}|\cdot |D|^{k+1}),
	\]
	up to logarithmic factors.
\end{proof}

Note also that, given a "tree decomposition" of a "structure" $\?A$,
and a "substructure" $\?B$ of $\?A$, by intersecting each "bag" with $B$,
we obtain a "tree decomposition" of $\?B$. It follows that the "tree-width"
of a "substructure" is always upper bounded by the "tree-width" of the full "structure".
In other words, "conjunctive queries" of "tree-width" at most $k\in\N$
form a "monotone class of CQs".

Grohe, Schwentick and Segoufin proved that there
are no graph property other than "tree-width" that ensures
polynomial time evaluation 
\cite[Corollary~19]{GroheSchwentickSegoufin2001Evaluation}.%
Importantly, this statement deals with \emph{graph properties},
"ie" with classes of CQs defined by restricting their underlying "structure".
We will see next that actually there are other classes of CQs
with tractable evaluation.

\paragraph*{Bounded Semantic Tree-Width.}
As mentioned in \Cref{sec:intro-existential}, \Cref{prop:eval-CQ-bounded-tw}
together with the notion of "core" actually yields a tractability result
for a larger class of queries than those of bounded tree-width.

\begin{proposition}
	For any $k\in\N$, the "CQ evaluation problem",
	restricted to "conjunctive queries" that are "semantically equivalent" 
	to a "CQ" of "tree-width" at most $k$ is "fixed parameter tractable"
	when parametrized by the size of the query.
\end{proposition}

\begin{proof}
	The algorithm goes as follows:
	we start by computing the "core@@CQ" $\core\gamma(\bar x)$
	of the "CQ" $\gamma(\bar x)$, and then instead of evaluating
	$\gamma(\bar x)$ on the "database", we instead evaluate
	$\core\gamma(\bar x)$, using the polynomial-time algorithm
	of \Cref{prop:eval-CQ-bounded-tw}.
	Overall, the algorithm runs in time
	\[
		\+O(f(\size{\gamma})\cdot|\vars(\gamma)|\cdot |D|^{k+1}),
	\]
	up to logarithmic factors, and where $f(\size{\gamma})$
	is the time required to compute the "core@@CQ" of
	$\gamma$.\footnote{This can be done in exponential time.}
	Hence, the problem is "FPT" when parametrized by $\size{\gamma}$.
\end{proof}

In fact, Dalmau, Kolaitis and Vardi improved this result: in a surprising twist, 
one does not need to explicitly the "core" to efficiently evaluate
a "CQ" that is "semantically equivalent" to one of small "tree-width".
They proved that this class could actually be evaluated in polynomial time
\cite[Corollary~5]{DalmauKolaitisVardi2002Constraint}.
Remarkably, Grohe then proved the converse implication: these 
are the only classes of CQs that are tractable!
\begin{proposition}[""Grohe's theorem"" {\cite[Theorem~1.1]{Grohe2007ComplexityHomomorphism}}]
	Assuming that "W[1]" $\neq$ "FPT", for any recursively enumerable
	class of "CQs", the following are equivalent:
	\begin{enumerate}
		\item there exists $k\in\N$ "st" the "tree-width" of the "cores@@cq"
			of the queries in the class is bounded by $k$;
		\item its evaluation problem is "fixed parameter tractable"
			when parametrized by the size of the "query";
		\item its evaluation problem can be solved in polynomial time.
	\end{enumerate}
\end{proposition}
The difficult implication in this theorem is of course (3) $\Rightarrow$ (1).
Grohe proves it by contraposition, by generalizing
the ideas of \cite{GroheSchwentickSegoufin2001Evaluation}:
in short, given a class whose "cores" have unbounded "tree-width",
using the Excluded Minor Theorem \cite[$\ast$ (1.5)]{RobertsonSeymour1986GraphMinors5}
one can find an "query" in the class whose "core" 
contains an arbitrarily large "grid". In turn, the clique problem,
which is "W[1]"-hard, is then reduced to the evaluation problem
for these "queries" with big grids.

\paragraph{Bounded Path-Width.}
We now focus on "path-width", which is a parameter upper-bounded
by the "tree-width".
So, if a "class of CQs" has bounded "path-width", then
it has bounded "tree-width" and so by \Cref{prop:eval-CQ-bounded-tw}
it can be evaluated in polynomial time.
We shall see that "CQs" of small "path-width"
can in fact be evaluated even more efficiently, namely in "NL"!
We define a ""path decomposition"" to be a "tree decomposition" $\tup{\?T,\bagmap}$
in which $\?T$ is a path, such as in \Cref{fig:ex-tree-dec}.
The \AP""path-width"" of a "structure" is the minimum of the "width" of
all of its "path decompositions".

\begin{lemma}[{\cite[Lemma~8.10]{FigueiraMorvan2025SemanticTreeWidthLMCS}}]
	\!\footnote[][5em]{\cite[Lemma~8.10]{FigueiraMorvan2025SemanticTreeWidthLMCS},
	corresponding to \Cref{lemma:evaluation-bounded-pathwidth} in this thesis,
	actually proved this result over the larger class of "UC2RPQs" of bounded 
	"path-width". The proof of the upper bound is exactly the same,
	but the lowerbound is \emph{marginally} harder.}
	\AP\label{lemma:evaluation-bounded-pathwidth-cq}
	For each $k \geq 1$, the "CQ evaluation problem", restricted to "CQs" of
	"path-width" at most $k$, is "NL"-complete.
\end{lemma}

\begin{figure*}[tb]
	\centering
	\subfloat[Partial homomorphism computed at the fourth step of the algorithm.]{
		\includegraphics[width=.45\linewidth]{fig/semantic-tw/eval-pw-nl-1.pdf}
	}
	\hfill
	\subfloat[Partial homomorphism computed at the fifth step of the algorithm.]{
		\includegraphics[width=.45\linewidth]{fig/semantic-tw/eval-pw-nl-2.pdf}
	}
	\caption{
		\AP\label{fig:eval-pw-nl}
		Algorithm to evaluate a "CQ" of "path-width" at most $k$ (here $k=2$)
		in "NL". Each subfigure represents a "path decomposition" of the "CQ"
		(on the left-hand side) and a "relational database" (on the right-hand side),
		together with a partial "homomorphism" from the first to the second.
	}
\end{figure*}

\begin{proof}
	\proofcase{Lower bound.}
	We reduce the problem of "Reachability in finite graphs"
	"NL"-hardness directly follows from the "NL"-hardness of
	the "reachability problem in directed graphs".
	Given an instance $\tup{\?G,s,t}$ of this problem,
	we reduce it to
	\[
		\tup{\?G', s, t} \FOmodels^?
		\rho(x_1,x_n) \defeq x_1 \to x_2 \land x_2 \to x_3 \land \dotsc \land x_{n-1} \to x_n,
	\]
	where $n = |G|$ and $\?G'$ is the "graph@@dir" obtained
	from $\?G$ by adding a self-loop on $t$.
	Clearly, there is a path from $s$ to $t$
	in $\?G$ "iff" there is a path from $s$ to $t$ of length at most $n$ in $\?G$---by pigeon-hole principle---, which in turn is equivalent to asking for a path from $s$ to $t$
	of length \emph{exactly} $n$ in $\?G'$ thanks to the extra self-loop.
	To conclude, note that $\rho$ has "path-width" one.

	\proofcase{Upper bound, first part: with the "path decomposition".}
	First, we assume that a "path decomposition" of width at most $k$ of the query of
	is also provided as part of the input. Moreover, we assume "wlog" that the input is "C2RPQ"---the extension to "UC2RPQ" being straightforward. So, we are given as input:
	\begin{itemize}
		\item a "database@@relpointed" $\tup{\?D, \bar d}$,
		\item a "CQ" $\gamma(\bar x)$, and
		\item a "path decomposition" $\langle T, \bagmap \rangle$ of "width" at 	
			most $k$ of $\gamma(\bar x)$.
	\end{itemize}
	The algorithm, illustrated in \Cref{fig:eval-pw-nl}, maintains a partial "homomorphism"
	$f\colon \?G \pto \?D$.
	We scan the "bags" of the decomposition from top to bottom.
	\begin{itemize}
		\item Initially---before even scanning the first "bag"---$f$ is the map with empty domain.
		\item Then, when scanning the $i$-th bag $b_i$,
			we start by restricting $f$ to variables of $\dom(f)\cap \bagmap(b_i)$.
			Then, we extend $f$ so that it is defined on the whole "bag" $\bagmap(b_i)$.
			For every variable $y$ in $\bagmap(b_i) \smallsetminus\dom(f)$:
			\begin{itemize}
				\item if it belongs to $\bar x$, say $y = x_i$, 
					we let $f(x_i) \defeq u_i$;
				\item otherwise, we non-deterministically guess the value of $f(y)$.
			\end{itemize}
			We then check, for every "atom" $\+R_{(k)}(x_1,\hdots,x_k)$ of $\gamma(\bar x)$ 
			"st" all $x_j$'s occur in $\bagmap(b_i)$ if
			$\tup{f(x_1), \dotsc, f(x_k)} \in \+R_{(k)}(\?D)$.
			If not, we reject. 
	\end{itemize}
	If the algorithm manages to scan the whole bag decomposition without rejecting, it accepts.

	Completeness of the algorithm is trivial. Correctness follows from the fact that if
	a variable occurs in "bags" $b_i$ and $b_k$ with $i \leq k$, then it must also belong to every
	"bag" $b_j$ for $j \in \intInt{i,k}$. As a consequence, a variable $x$ is assigned 
	exactly one value $f(x)$ during the whole process. 

	Concerning the space complexity,
	by construction, at the $i$-th step of the algorithm, $f$ is defined exactly on $b_i$, so on at most $k+1$ variables.
	And so, $f$ can be stored in space $(k+1)\log(|D|)$.
	We also need a counter with $\log(|T|)$ bits to scan through the "tagged path decomposition".
	Overall, the algorithm runs in non-deterministic space
	$\+O(k\log(|G|) + \log(|T|)) = \+O(\log(|G|) + \log(|T|))$,
	which is logarithmic in the size of the input.

	\proofcase{Upper bound, second part: without the "path decomposition".}
	Then, we claim that the original problem---when the "tagged tree decomposition" is not part of 
	the input---also lies in "NL". This is because one can compute, from $\gamma$, a
	"path decomposition" in (deterministic) logarithmic space by\footnote{This result is an 
	adaption of a similar statement for "tree-width" \cite[Theorem I.1, p. 143]{ElberfeldJakobyTantau2010Logspace}. Note that the promise that the query has bounded "path-width"---in fact bounded "tree-width" suffices---in a crucial assumption of  \cite[Theorem I.1, p. 143]{ElberfeldJakobyTantau2010Logspace}.} 
	\cite[Theorem 1.3, p. 2]{KintaliMunteanu2010Computing}. Then, a "path decomposition" can be turned into a 
	"tagged path decomposition" in (deterministic) logarithmic space by tagging an "atom"
	$x \atom{L} y$ in the first bag containing both $x$ and $y$.
	The conclusion follows since functions computable in non-deterministic logarithmic space
	are closed under composition \cite[Lemma 4.17, p. 88]{AroraBarak2009ComputationalComplexity}. 
\end{proof}

\subsection{Unions of Conjunctive Queries}
\label{sec:prelim-db-ucq}

\begin{marginfigure}
	\centering
	\directlua{width = 2.3; height = 1.4}
\input{tikz/prelim-databases/abstract-lattice.lua}%do not indent!!!
	\begin{tikzpicture}[every node/.style={inner sep=0pt,outer sep=0pt},font=\footnotesize]
		\directlua{draw_lattice()}
		\begin{scope}
\begin{luacode}
			make_clip()
			x = -1.25
			y = -.2
			d1 = .5
			d2 = .75
			d3 = .9
			d4 = .85
			h = height ; w = width ; s = h/w
			colour = "cBlue"
			tex.print(string.format("\\begin{scope}[xshift=%f cm, yshift=%f cm]", x, y+height))
			tex.print(string.format("\\draw[draw=%s, fill=%s, fill opacity=.4] (0,%f) -- (%f,%f) -- (%f, %f) -- (%f,%f) -- (%f,%f) -- (%f,%f) -- (%f,%f) -- (%f,%f) -- (%f, 0) -- cycle;", colour, colour, -height, d1, -h+d1*s, d1+d2, -h+(d1-d2)*s, d1+d2+d3, -h+(d1-d2+d3)*s, d1+d2+d3+d4, -h+(d1-d2+d3-d4)*s, d1+d2+d3+d4+w, (d1-d2+d3-d4)*s, d1+d2+d3+d4+w, h, -w, h, -width))
			-- tex.print(string.format("\\node[circle, fill=%s, minimum size=4pt, outer sep=1pt] at (0,%f) {};", colour, -height))
			tex.print("\\end{scope}")
\end{luacode}
		\end{scope}
	\end{tikzpicture}
	\caption{
		\AP\label{fig:ex-ucq} Semantics of a "union of conjunctive queries" (in blue)
		in the distributive lattice of "relational databases".
	}
\end{marginfigure}
\begin{marginfigure}
	\centering
	\includegraphics[width=\linewidth]{fig/prelim-db/Houches.jpg}
	\caption{
		The study of (co-)"UCQs" is intriguingly popular amongst finite model theorists. 
		\href{https://fr.m.wikipedia.org/wiki/Fichier:TER\_en\_gare\_des\_Houches\_(Haute-Savoie).JPG}{\emph{TER en Gare des Houches}}, by Florian Pépellin,
		licensed under "CC BY SA 3.0".
	}
\end{marginfigure}
We now show that the desirable properties of "conjunctive queries" can be
lifted to finite unions of such queries.
As mentioned in \Cref{sec:prelim-db-poset-cq}, "conjunctive queries"
are not closed under semantical union: for instance,
the "query" ``the "database@@rel" contains either an $a$-edge or a $b$-edge''
cannot be expressed by a "conjunctive query".
In fact, our graphical depiction of the distributive lattice of "relational databases"
precisely helps us understand this.

Formally, we define a ""union of conjunctive queries"", or \reintro{UCQ} for short,
as a finite set of "conjunctive queries" that all have the same number
of "output variables". This set is denoted disjunctively.
Its semantics is defined as the union of the semantics of the "conjunctive queries" it
contains.
\footnote[][2em]{Strictly speaking it is not necessary
to assume that these "output variables" are equal, however we can assume "wlog" that
it is the case, by $\alpha$-renaming.}
For instance, if $\gamma(x) = x \atom{a} y$ outputs all vertices
with an outgoing $a$-edge and $\delta(x') = x' \atom{b} y' \atom{c} z'$
outputs all vertices with an outgoing $bc$-path, then
$\gamma(x) \lor \delta(x')$ is the "UCQ" asking for all nodes
that are either the source of an $a$-edge or of a $bc$-path.
We denote "UCQs" with capital Greek letters,
and \AP we call ""disjunct"" of $\Gamma$ any "conjunctive query" belonging to a
"UCQ" $\Gamma$.

Notice that "union of conjunctive queries" are also "closed under homomorphisms".
Graphically, we represent them as… unions of "conjunctive queries":
instead of being diamond-shaped, "UCQs" will hence be depicted
as inverted mountain ranges, see \Cref{fig:ex-ucq}.
By the proof of \Cref{prop:codd-thm}, we can notice that "union of conjunctive queries"
are as expressive as "existential-positive formulas", "ie" "first-order formulas"
without universal quantifiers and negation.

\begin{proposition}
	Let $\Gamma$ be a "UCQ". The following are equivalent:
	\begin{enumerate}
		\item $\Gamma$ is "sementically equivalent" to a "conjunctive query";
		\item the semantics of $\Gamma$ contains a unique "minimal element";
		\item some "disjunct" of $\Gamma$ "contains@@contained" all "disjuncts";
		\item $\Gamma$ is "sementically equivalent" to one of its "disjuncts";
		\item $\Gamma$ is "sementically equivalent" to the "weak union" of its "disjuncts";
	\end{enumerate}
\end{proposition}
\begin{figure}
	\centering
	\subfloat[Two "CQs" $\gamma$ and $\delta$ whose semantical union is
		equivalent to a "CQ".]{
\directlua{width = 2.3; height = 1.4}
\input{tikz/prelim-databases/abstract-lattice.lua}%do not indent!!!
	\begin{tikzpicture}[every node/.style={inner sep=0pt,outer sep=0pt},font=\footnotesize]
		\directlua{draw_lattice()}
		\begin{scope}
			\directlua{make_clip()}
			\directlua{draw_cq(.5, -.6, 'c0', 'x')}
			\directlua{draw_cq(.65, .2, 'c2', 'y')}
			\node[below=2pt of x, c0] {$\gamma$};
			\node[below=2pt of y, c2] {$\delta$};
		\end{scope}
	\end{tikzpicture}
	}
	\hfil
	\subfloat[Two "CQs" $\gamma$ and $\delta$ whose semantical union is not
		equivalent to a "CQ". We also represented their "weak union".]{
	\directlua{width = 2.3; height = 1.4}
\input{tikz/prelim-databases/abstract-lattice.lua}%do not indent!!!
	\begin{tikzpicture}[every node/.style={inner sep=0pt,outer sep=0pt},font=\footnotesize]
		\directlua{draw_lattice()}
		\begin{scope}
			\directlua{make_clip()}
			\directlua{draw_cq(.167, -.607, 'cPurple', 'z')}
			\directlua{draw_cq(.5, -.4, 'c0', 'x')}
			\directlua{draw_cq(-.5, -.2, 'c2', 'y')}
			\node[below=2pt of x, c0] {$\gamma$};
			\node[below=2pt of y, c2] {$\delta$};
			\node[below=3.5pt of z, cPurple] {$\gamma \weakunion \delta$};
		\end{scope}
	\end{tikzpicture}
	}
	\caption{
		\label{fig:ucq-equiv-cq} When is a "union of conjunctive queries"
		actually equivalent to a "conjunctive query"?
	}
\end{figure}
 
\begin{proof}
	All the intuitions are provided in \Cref{fig:ucq-equiv-cq}.
	
	\proofcase{(1) $\Rightarrow$ (2).} If $\Gamma$ is "semantically equivalent"
	to a "CQ" $\delta$, then the "canonical database" $\?D$ of $\delta$ is
	the unique minimal element in the semantics of $\Gamma$.

	\proofcase{(2) $\Rightarrow$ (3).} If the "semantics" of $\Gamma$
	contains a unique minimal element, say $\?D$, then since $\?D \FOmodels \Gamma$,
	there exists a "disjunct" $\gamma$ of $\Gamma$ "st" $\?D \FOmodels \gamma$.
	By minimality of $\?D$, it follows that $\gamma$ is actually the "canonical CQ" of $\?D$,
	and again by minimality of $\?D$ it follows that all "disjuncts" are "contained" in $\gamma$.

	\proofcase{(3) $\Rightarrow$ (4).} If $\Gamma = \gamma_1 \lor \dotsc \lor \gamma_k$
	has a "disjunct", say $\gamma_i$, that contains all other disjuncts, then
	\[
		\Gamma = \gamma_1 \lor \dotsc \lor \gamma_k \contained
		\gamma_i \lor \dotsc \lor \gamma_i \semequiv \gamma_i \contained \Gamma
	\]
	and so $\Gamma$ is "semantically equivalent" to its "disjunct" $\gamma_i$.

	\proofcase{(4) $\Rightarrow$ (5).} If $\Gamma = \gamma_1 \lor \dotsc \lor \gamma_k$ is "semantically equivalent" to
	one of its disjuncts, say $\gamma_i$, then
	for each $j$ we have $\gamma_j \contained \Gamma \semequiv \gamma_i$,
	and so by definition of the "weak union" as the least upper bound,
	it follows that $\gamma_1 \weakunion \dotsc \weakunion \gamma_k \semequiv \gamma_i$.

	\proofcase{(5) $\Rightarrow$ (1).} If $\Gamma$ is "semantically equivalent" to the
	"weak union" of its "disjuncts", then since this query is a "CQ", it
	is equivalent to a "CQ"…
\end{proof}

\begin{proposition}
	Given two "UCQs" $\Gamma$ and $\Delta$, we have $\Gamma \contained \Delta$
	if, and only if, for every "disjunct" $\gamma \in \Gamma$, there exists
	a "disjunct" $\delta \in \Delta$ "st" $\gamma \contained \delta$.
\end{proposition}

\begin{proof}
	The right-to-left implication is trivial.
	For the converse one, assume that $\Gamma \contained \Delta$,
	and let $\gamma$ be a "disjunct" of $\Gamma$.
	Letting $\?G$ be its "canonical database", we have by "duality" that
	$\?G \FOmodels \Gamma$
	and since $\Gamma \contained \Delta$, it follows that $\?G \FOmodels \Delta$,
	and hence $\?G \FOmodels \delta$ for some "disjunct" $\delta \in \Delta$,
	and so, by "duality", $\gamma \contained \delta$. 
\end{proof}

\begin{corollary}
	"Containment" and "semantical equivalence" of "unions of conjunctive queries"
	are "NP"-complete.
\end{corollary}

Essentially, these results are permitted, at least in part, by the fact that semantical union
is well-behaved with respect to "duality": this is mostly because their semantics 
is "closed under homomorphisms". Hopefully, one could hope to find larger
query languages satisfying this property, and then deduce decidability results via "duality".
Both unfortunately and expectedly, it turns out that there
are no other first-order queries which are "closed under homomorphism".\AP
\begin{proposition}[""Rossman's theorem"", {\cite[Theorem~1.7]{Rossman2008Homomorphism}}]
	\!\footnote{Actually the full statement of the theorem is
	slightly more precise and relates the quantifier-rank of the formulas.
	The original construction was far from optimal, and it was
	recently shown by the same author
	that this rank can actually be preserved by the construction
	\cite[Theorem~1.4]{Rossman2025Equirank}.}%
	\footnote{Both references mention "first-order sentences"; however we do not see
	any reason why it would not apply to all "first-order formulas".}
	The semantics over "finite relational structures"
	of a "first-order sentence" is "closed under homomorphisms"
	if, and only if, it is equivalent to a "union of conjunctive queries".
\end{proposition}

We leave to the reader the care to show that the other properties of "CQs"
can be lifted to "UCQs", for instance:
\begin{itemize}
	\item starting from a "UCQ" $\gamma_1 \lor \dotsc \lor \gamma_k$,
		the "UCQ" obtained by (1) considering the "cores@@CQ"
		$\coreCQ{\gamma_1}$, $\dotsc$, $\coreCQ{\gamma_k}$,
		(2) putting aside those that are "contained" in another "core",
		and (3) taking their union
		yields a "UCQ" that is "semantically equivalent" to the
		original one, and minimal under most reasonable metrics;
	\item the evaluation of "UCQs" of bounded "tree-width"---we naturally
		extend the notion of "tree-width" to unions by letting it
		be the maximum of the "tree-width" of its "disjuncts"---is
		polynomial time. 
\end{itemize}