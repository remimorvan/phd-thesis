\section{Relational Databases}

\subsection{SQL and First-Order Logic}

The most common model of databases is by far that of "relational databases",
in which data is stored in \emph{tables}: an example is depicted
in \Cref{fig:relational-database-cinema}.

\begin{table}
	\centering%
	\input{tikz/intro/relational-database-cinema.tex}
	\caption{
		\AP\label{fig:relational-database-cinema}
		A "relational database" consisting of three tables, representing data
		stored by a cinema. (Replica of \Cref{fig:example-db-as-rel}.)
	}
\end{table}

Formally, a \AP""relational database"" $\?D$ over a "purely relational signature" $\sigma$
consists of, for each "predicate" $\+R$ of arity $k$ in $\sigma$,
a $k$-ary relation $\+R_{(k)}(\?D)$.%
\footnote{It is often asked that at least one $\+R_{(k)}(\?D)$ is non-empty.
Whether this condition is imposed does change the theory---for instance the "first-order sentences"
that are valid over all non-empty structures is a strict subset of
those valid over all (possible empty) structures.
However, this condition is mostly required for historical reasons,
and whether the databases are allowed to be non-empty
will be of little importance for the query languages we will consider.}
Each tuple of some relation $\+R_{(k)}(\?D)$ is called a \emph{fact}.
From a practical perspective, relations model the tables,
while each fact correspond to some row: for 
instance the database of \Cref{fig:relational-database-cinema}
has three relations, twelve facts and no constants.%
\footnote{Many variations on the definition above exists:
for instance the columns of the table are often given a name (called \emph{attribute}),
see "eg" \cite[\S\!\S~3.1--3.2]{AbiteboulHullVianu1995Databases}.
This is usually done to make the syntax of relational algebra for readable,
however this is only syntactic sugar \cite[Proposition~5.1.2]{AbiteboulHullVianu1995Databases}.}

Naturally, each "relational database" yields a "$\sigma$-structure" whose
domain is the set of elements occurring in some fact of the database.
This structure has the property that each vertex belongs to some "hyperedge":
in other words, it has no \AP""isolated vertices"".
This mapping is in fact one-to-one: "relational databases" over $\sigma$
are in bijection with "$\sigma$-structures" with no "isolated vertices".
\AP""Pointed relational databases"" are defined analogously to
"pointed relational structures".

As mentioned in \Cref{ch:intro}, from a theoretical perspective,
a very natural way of querying these "structures"
is "via" "first-order logic". Remarkably, it is exactly as expressive 
as the fragment of SQL consisting of queries generated by
\begin{align}
	\phi_{(k)}\; & \mathrel{{:}{:}{=}} \sqlop{SELECT DISTINCT} \textrm{ attribute}_1, \dotsc, \textrm{ attribute}_k\notag\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{FROM } \phi_{(i_1)}, \dotsc, \phi_{(i_n)}\notag\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{WHERE} \textrm{ some condition} \label{eq:sql-fo}\\
	& \;\mid \textrm{some table of arity $k$} \notag\\
	& \;\mid \phi_{(k)} \mathrel{\sqlop{ UNION }} \phi_{(k)}
		\mid \phi_{(k)} \mathrel{\sqlop{ EXCEPT }} \phi_{(k)}
		\mid \phi_{(k)} \mathrel{\sqlop{ INTERSECT }} \phi_{(k)}, \notag
\end{align}
where $i_1 + \dotsc + i_n = k$ and the condition after $\sqlop{WHERE}$
is a conjunction of equalities between attributes.
Dealing with the arity $k \in \N$ is required to ensure "eg" that the union 
is homogeneous---"ie" that all facts in the union have the same arity.%
\footnote{Also, the \textsf{DISTINCT} keyword is only necessary because SQL
has a multiset semantics rather than a set-based semantics…}

\begin{proposition}[Codd's theorem {\cite[\S~4]{Codd1972RelationalCompleteness}}]
	\!\footnote{Codd's theorem actually deals
	with \emph{relational algebra} rather than SQL.
	The equivalence between \emph{relational algebra} and the fragment
	\eqref{eq:sql-fo} of SQL is however straightforward.
	See also \cite[Theorem~5.4.6]{AbiteboulHullVianu1995Databases}.}
	\AP\label{prop:codd-thm}
	"First-order logic" over "$\sigma$-structures" with no "isolated vertices"
	is equally expressive to the SQL fragment defined in \eqref{eq:sql-fo}.
	Moreover, this equivalence is effective.
\end{proposition}

\begin{proof}[Proof sketch]
	\emph{Warning:} dealing with all the subtleties of the proof is actually
	somewhat tedious. Hence, we provide an \emph{informal} proof,
	which prioritizes intuition over formalism.

	Expressing a SQL query as a "first-order formula" is intuitive,
	by generalizing the idea given in \Cref{sec:intro-cq}:
	\begin{itemize}
		\item $\sqlop{UNION}$, $\sqlop{EXCEPT}$ AND $\sqlop{INTERSECT}$
			are interpreted as the union, set difference ("ie" $- \land (\neg -)$)
			and intersection;
		\item a table of arity $k$, modelled as a relation $\+R_{(k)}$,
			is encoded as the atomic formula
			\[
				\phi_{(k)}(x_1,\hdots,x_k) \defeq \+R_{(k)}(x_1,\hdots,x_k)
			\]
			with $k$ free variables which are all fresh;
		\item a query
			\begin{align*}
				& \sqlop{SELECT DISTINCT} \textrm{ attribute}_1, \dotsc, \textrm{ attribute}_k \\
				& \sqlop{FROM } \phi^1_{(i_1)}, \dotsc, \phi^n_{(i_n)} \\
				& \sqlop{WHERE} \theta 
			\end{align*}
			is encoded as
			\[
				\psi(y_1,\hdots,y_k) \defeq
				\exists \bar x.\;
				\phi^1_{(i_1)}(x^1_1,\dotsc,x^1_{i_1})
				\land \dotsc \land
				\phi^n_{(i_n)}(x^n_1,\dotsc,x^n_{i_n})
				\land \theta,
			\]
			with $y_1$, $\dotsc$, $y_k$ being the variable associated
			to the attributes---"eg" if $\textrm{attribute}_1$ is the
			third attribute of $\phi^2$, then $y_1 \defeq x^2_3$---
			and $\bar x$ is the tuple of all variables of the form $x^i_j$
			that are distinct from the $y_i$'s.
	\end{itemize}
	
	The converse encoding, "ie" from first-order logic to SQL queries,
	is a little more tricky:
	\begin{itemize}
		\item union is encoded with \sqlop{UNION},
			intersection and existential quantification with
			\sqlop{SELECT DISTINCT}-\sqlop{FROM}-\sqlop{WHERE};
		\item we encode negation using \sqlop{EXCEPT} and a SQL query
			that outputs every $k$-tuple of vertices of the "structure"---this query can
			be written as a big union of \sqlop{SELECT DISTINCT}-\sqlop{FROM}
			queries;
		\item lastly, universal quantification can then be obtained
			using the tautology
			\[\forall x.\; \phi(x) \equiv \neg\exists x.\; \neg \phi(x).\qedhere\]
	\end{itemize}
\end{proof}

A crucial ingredient that ensures the correctness of these encodings
is actually the fact that "relational databases" are encoded
as "relational structures" \textbf{with no "isolated variables"}.%
\footnote{The restriction of "first-order logic" to
"relational databases" is usually called \emph{relational calculus}.}
Take for instance the "first-order formula"
$\neg \textsc{Room}(x,y)$:
we expressed it in SQL as
\[
	\textrm{All pairs}
	\mathrel{\sqlop{ EXCEPT }}
	(\sqlop{SELECT DISTINCT } x, y \mathrel{\sqlop{ FROM }} \textsc{Room})\; 
\]
where `All pairs' is a query outputting all pairs in the database.
The equivalence, or more precisely the fact that the semantics
of the "first-order formula" over the "relational structure"
is included in the semantics of the SQL query over the "relational structure", is
precisely permitted by the lack of "isolated vertices" in
the "structure": for more details, we refer the reader 
to the term ``active domain'' in \cite{AbiteboulHullVianu1995Databases}.%
\footnote{The same query is actually a good example of why there is no built-in
negation in SQL, even though it would not change its expressiveness: it
is actually very hard to image a situation where
knowing that `Xavier Dolan' is not the id of a room with capacity `2025-03-28 14:00'
would be useful…}

The expressiveness of this fragment of SQL however comes to the cost
of computational efficiency.

\begin{proposition}[Folklore]
	Given a "first-order formula" $\phi(\bar x)$, a "relational structure" $\?D$
	with no "isolated vertices", and a tuple $\bar d$, deciding
	if $\bar d \in \semFO{\phi(\bar x)}{\?D}$
	is "PSpace"-complete.
\end{proposition}

\begin{proof}[Proof sketch]
	The upper bound can be proven by considering the naïve algorithm
	that recurses on the formula.
	The lower bound follows from a trivial reduction from
	the "quantified Boolean formula problem".
\end{proof}

Even worth, when turning to the \emph{static analysis} of these queries, 
the problems become undecidable. Given two (semantical) "queries" $\phi$ and $\psi$,
we say that they are "semantically equivalent"---implicitly
over "finite@@struct" "relational databases"---when for every "finite@@struct" "relational databases" $\?D$, we have $\?D \in \phi$ "iff" $\?D \in \phi'$.
This fact is denoted by \AP$\phi \intro*\semequiv \phi'$.

\begin{proposition}[Trakhtenbrot $\ast$ Databases, see "eg" {\cite[Theorem~6.3.1 \& Corollary~6.3.2]{AbiteboulHullVianu1995Databases}}]
	\!\footnote{This result is often incorrectly confused with
	"Trakhtenbrot's theorem", which deals with all "relational structures".
	However, the notion of "semantical equivalence" differs when considered
	over "relational databases" or all "relational structures".}
	\AP\label{prop:Trakhtenbrot-db}
	It is undecidable whether a
	"first-order formula" is satisfiable over finite "relational databases".
	In turn, validity and "semantical equivalence" are also undecidable.
\end{proposition}

In turn, it means that there is no hope to optimize a SQL query from the
fragment \eqref{eq:sql-fo}, in the sense of \Cref{sec:intro-existential}.%

\begin{corollary}[Folklore than is unfortunately often not mentionned, see "eg"
	{\cite[Remark~5.3]{AdlerWeyer2012TreeWidthFirstOrder}}]
	\label{coro:undecidability-minimization}
	Given a "first-order formula" $\phi$ and $k\in\N$, it is undecidable
	whether $\phi$ is "semantically equivalent" to a "formula@@FO" with at most $k$ variables.
\end{corollary}

\subsection{Conjunctive Queries to the Rescue}

The undecidability results of \Cref{prop:Trakhtenbrot-db,coro:undecidability-minimization},
together with the fact that queries occurring in practice---see \Cref{sec:intro-cq}---are
much simpler than the formulas occurring in the undecidability proof motivate
the study of well-behaved query fragments.

"Conjunctive queries" arise as either the fragment
\begin{align}
	\phi_{(k)}\; & \mathrel{{:}{:}{=}} \sqlop{SELECT DISTINCT} \textrm{ attribute}_1, \dotsc, \textrm{ attribute}_k\notag\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{FROM } \phi_{(i_1)}, \dotsc, \phi_{(i_n)}\label{eq:sql-cq}\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{WHERE} \textrm{ some condition} \notag\\
	& \;\mid \textrm{some table of arity $k$} \notag
\end{align}
of SQL, where, once again, $i_1 + \dotsc + i_n = k$ and the condition after $\sqlop{WHERE}$
is a conjunction of equalities between attributes.
From the proof of \Cref{prop:codd-thm} it actually follows that this fragment is exactly
as expressive as the fragment of "first-order logic", restricted to "relational databases",
generated by 
\begin{align}
	\phi \mathrel{{:}{:}{=}} \+R_{(k)}(x_1,\dotsc,x_k) \mid \phi \land \phi \mid \exists x.\; \phi,
	\label{eq:fo-cq}
\end{align}
where $\+R_{(k)}$ ranges over the "signature".

Now observe that, when dealing with the fragment \eqref{eq:fo-cq},
the "first-order formula" $(\exists x.\; \phi(x, \bar y)) \land \psi(\bar z)$
is equivalent to $\exists x'.\; (\phi(x', \bar y) \land \psi(\bar z))$
where $x'$ is any variable that occurs neither in $\bar y$ nor in $\bar z$.
For instance, we have 
\[
	(\exists x.\, \+P(x)) \land (\exists x.\, \exists y.\,\+R(x,y))
	\semequiv
	\exists z.\,\exists x.\, \exists y.\, \+P(z) \land \+R(x,y).
\]
This leads to a simple rewriting system that puts every formula from 
\eqref{eq:fo-cq} in so-called "prenex form".

\begin{proposition}[""Prenex form""]
	\AP\label{prop:prenex-form}
	Every formula from \eqref{eq:fo-cq} can be written in the form
	\begin{align}
		\exists \bar x.\, \bigwedge_{i=1}^n \+R^i_{(k_i)}(y^i_1,\dotsc,y^i_{k_i}).
		\label{eq:prenex-fo}
	\end{align}
\end{proposition}

\Cref{prop:prenex-form} has remarkable consequences.
Translating back the "formulas@@FO" in "prenex form" to 
SQL queries, it implies that the fragment \eqref{eq:sql-cq}
is no more expressive than its induction-free fragment
\begin{align}
	\phi_{(k)}\; & \mathrel{{:}{:}{=}} \sqlop{SELECT DISTINCT} \textrm{ attribute}_1, \dotsc, \textrm{ attribute}_k\notag\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{FROM } \textrm{table}_{(i_1)}, \dotsc, \textrm{table}_{(i_n)}\label{eq:sql-cq-bis}\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{WHERE} \textrm{ some condition}. \notag
\end{align}

Formally, we define a \AP"conjunctive query" to be
any "first-order formula" in "prenex form"---see \Cref{eq:prenex-fo}.
Recall that, as mentioned in \Cref{rk:prelim-formula-tuple},
we assume that "formulas" comes with a tuple of variables,
containing all free variables, potentially with repetition.
Hence, a \AP""conjunctive query"", or \reintro{CQ} for short, amounts to a finite set
of atomic formulas of the form $\+R_{(k)}(x_1,\hdots,x_k)$, called ""atoms@@cq"",
together with tuple of variables $\bar x$, called ""free variables@@cq""
or ""output variables@@cq"". The set of atoms is denoted conjunctively.
So, an example of "conjunctive query" is
\begin{align*}
	\gamma(\textsf{title}, \textsf{time}) \defeq\; 
	& \textsc{Movies}(\textsf{movie\_id}, \textsf{title}, \textsf{length}, \textsf{director}) \\
	& \land
	\textsc{Projections}(\textsf{movie\_id}, \textsf{room\_id}, \textsf{time}).
\end{align*} 
Semantically, it is interpreted as the "first-order formula" in "prenex form"
in which every variable that is not an "output variable" is quantified existentially,
giving in our case
\begin{align*}
	\gamma(\textsf{title}, \textsf{time}) \defeq\; 
	& \exists \textsf{movie\_id}.\, 
	\exists \textsf{length}.\, 
	\exists \textsf{director}.\,
	\exists \textsf{room\_id}.\, \\
	& \hphantom{\land~} \textsc{Movies}(\textsf{movie\_id}, \textsf{title}, \textsf{length}, \textsf{director}) \\
	& \land
	\textsc{Projections}(\textsf{movie\_id}, \textsf{room\_id}, \textsf{time}).
\end{align*} 

Interestingly, the semantics of "conjunctive queries" can be described using "homomorphisms",
via the theory of \emph{duality}.
\begin{definition}
	The "canonical database" associated to a "conjunctive query"
	\[
		\gamma(\bar x) = \bigwedge_{i=1}^n \+R^i_{(k_i)}(y^i_1,\dotsc,y^i_{k_i})
	\]
	over the "purely relational signature" $\sigma$ is the "pointed relational database"
	over $\sigma$ with tuple $\bar x$ and whose facts are
	$\+R^i_{(k_i)}(y^i_1,\dotsc,y^i_{k_i})$ for $i \in \intInt{1,n}$.
\end{definition}
We say that a "conjunctive query" is ""Boolean@@cq"" when it has no "output variables".
In this case, its "canonical database" is not only a "pointed relational database" but
in fact a "relational database".

\begin{proposition}[""Duality""]
	\AP\label{prop:duality}
	Let $\gamma(\bar x)$ be a "conjunctive query",
	and let $\tup{\?G, \bar x}$ denote its "canonical database".%
	\footnote{We denote the "canonical database" using the Roman
	uppercase associated with the Greek letter used to denote
	the query.}
	For any "pointed relational database" $\tup{\?D, \bar d}$,
	we have
	\[
		\bar d \in \semFO{\gamma(\bar x)}{\?D}
		\qquad\text{"iff"}\qquad
		\tup{\?G, \bar x} \homto \tup{\?D, \bar d}.
	\]
\end{proposition}

\begin{proof}
	This follows from the definition of "homomorphisms" and
	the semantics of "first-order logic".
\end{proof}

Duality has \emph{many} consequences. First, the following evaluation problem
lies in "NP", as it can be encoded into a "homomorphism problem".
\decisionproblem{""Conjunctive Query Evaluation""}{
	A "signature" $\sigma$,
	a "conjunctive query" $\gamma(\bar x)$ over $\sigma$,
	and a "pointed relational $\sigma$-database" $\tup{\?D, \bar d}$.
}{
	Does $\bar d \in \semFO{\gamma(\bar x)}{\?D}$?
}
For "Boolean conjunctive queries", both tuples are empty, and so
this amounts to asking whether the query is true on the "database@@rel".
More importantly, "duality" has the consequence that
"semantical equivalence", as well as the finer notion of "containment@@cq",
are decidable for "CQs".

Given two "CQs" $\gamma(\bar x)$ and $\gamma'(\bar x')$,
we say that $\gamma(\bar x)$ is ""contained"" in $\gamma'(\bar x')$
whenever (1) $\bar x$ and $\bar x'$ have the same arity, and (2)
$\semFO{\gamma(\bar x)}{\?D} \subseteq \semFO{\gamma'(\bar x')}{\?D}$
for every "relational database" $\?D$. This is denoted by
$\gamma(\bar x) \intro*\contained \gamma'(\bar x')$.
Clearly, "semantical equivalence" can be obtained as the symmetric
closure of "containment".

\begin{proposition}
	Let $\gamma(\bar x)$ and $\gamma'(\bar x')$ be two "CQs".
	The following are equivalent:
	\begin{enumerate}
		\item $\gamma(\bar x) \intro*\contained \gamma'(\bar x')$;
		\item $\tup{\?G, \bar x} \FOmodels \gamma'(\bar x')$;
		\item $\tup{\?G', \bar x'} \homto \tup{\?G, \bar x}$,
	\end{enumerate}
	where $\tup{\?G, \bar x}$ and $\tup{\?G', \bar x'}$ are the "canonical databases"
	of $\gamma(\bar x)$ and $\gamma'(\bar x')$, respectively.
\end{proposition}

\begin{proof}
	\proofcase{(1) $\Rightarrow$ (2).}
	By "duality", $\tup{\?G, \bar x}$ is a model of $\gamma(\bar x)$,
	and so, since this query is "contained" in $\gamma'(\bar x')$,
	it follows that $\tup{\?G, \bar x} \FOmodels \gamma'(\bar x')$.

	\proofcase{(2) $\Rightarrow$ (3).} By "duality".

	\proofcase{(3) $\Rightarrow$ (1).} Assume that
	$\tup{\?G', \bar x'} \homto \tup{\?G, \bar x}$,
	and let us prove that $\gamma(\bar x) \contained \gamma'(\bar x')$.
	Let $\tup{\?D, \bar d}$ be a "pointed relational database",
	and assume that $\tup{\?D, \bar d} \FOmodels \gamma(\bar x)$.
	By "duality", we get $\tup{\?G, \bar x} \homto \tup{\?D, \bar d}$,
	and by precomposing with any "homomorphism" witnessing
	that $\tup{\?G', \bar x'} \homto \tup{\?G, \bar x}$,
	we get that $\tup{\?G', \bar x} \homto \tup{\?D, \bar d}$.
	Once again, by "duality", this amounts to $\tup{\?D, \bar d} \FOmodels \gamma'(\bar x')$,
	which concludes the proof that $\gamma(\bar x) \contained \gamma'(\bar x')$.
\end{proof}

\begin{itemize}
	\item combined complexity / data complexity
	\item duality w/ table of equivalence (vertex <-> variable ; disjoint union <-> disjoint conjunctions)
	\itemAP $\intro*\underlying{\gamma}$ and ""underlying graph""
	\itemAP ""equality atom""
	\itemAP ""evaluation map@@cq"" (explain why notion is necessary by pointing to "evaluation map" for CRPQs)
	\itemAP ""disjunct""
	\itemAP ""conjunctive query evaluation""
\end{itemize}

\subsection{Static Analysis of Conjunctive Queries}

\subsection{Intermezzo: Parametrized Complexity Classes}

\begin{itemize}
	\itemAP ""FPT""
	\itemAP ""W1""
	\itemAP ""XP""
\end{itemize}

\subsection{Beyond Conjunctive Queries}