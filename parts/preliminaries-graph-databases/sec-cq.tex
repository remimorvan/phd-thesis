\section{Relational Databases}

\subsection{SQL and First-Order Logic}

The most common model of databases is by far that of "relational databases",
in which data is stored in \emph{tables}: an example is depicted
in \Cref{fig:relational-database-cinema}.

\begin{table}
	\centering%
	\input{tikz/intro/relational-database-cinema.tex}
	\caption{
		\AP\label{fig:relational-database-cinema}
		A "relational database" consisting of three tables, representing data
		stored by a cinema. (Replica of \Cref{fig:example-db-as-rel}.)
	}
\end{table}

Formally, a \AP""relational database"" $\?D$ over a "purely relational signature" $\sigma$
consists of, for each "predicate" $\+R$ of arity $k$ in $\sigma$,
a $k$-ary relation $\+R_{(k)}(\?D)$.%
\footnote{It is often asked that at least one $\+R_{(k)}(\?D)$ is non-empty.
Whether this condition is imposed does change the theory---for instance the "first-order sentences"
that are valid over all non-empty structures is a strict subset of
those valid over all (possible empty) structures.
However, this condition is mostly required for historical reasons,
and whether the databases are allowed to be non-empty
will be of little importance for the query languages we will consider.}
Each tuple of some relation $\+R_{(k)}(\?D)$ is called a \emph{fact}.
From a practical perspective, relations model the tables,
while each fact correspond to some row: for 
instance the database of \Cref{fig:relational-database-cinema}
has three relations, twelve facts and no constants.%
\footnote{Many variations on the definition above exists:
for instance the columns of the table are often given a name (called \emph{attribute}),
see "eg" \cite[\S\!\S~3.1--3.2]{AbiteboulHullVianu1995Databases}.
This is usually done to make the syntax of relational algebra for readable,
however this is only syntactic sugar \cite[Proposition~5.1.2]{AbiteboulHullVianu1995Databases}.}

Naturally, each "relational database" yields a "$\sigma$-structure" whose
domain is the set of elements occurring in some fact of the database.
This structure has the property that each vertex belongs to some "hyperedge":
in other words, it has no \AP""isolated vertices"".
This mapping is in fact one-to-one: "relational databases" over $\sigma$
are in bijection with "$\sigma$-structures" with no "isolated vertices".
\AP""Pointed relational databases"" are defined analogously to
"pointed relational structures".

\begin{hypothesisnotation}
	We identify (pointed) "relational databases" with (pointed) "relational structures"
	with no "isolated vertices".
\end{hypothesisnotation}

As mentioned in \Cref{ch:intro}, from a theoretical perspective,
a very natural way of querying these "structures"
is "via" "first-order logic". Remarkably, it is exactly as expressive 
as the fragment of SQL consisting of queries generated by
\begin{align}
	\phi_{(k)}\; & \mathrel{{:}{:}{=}} \sqlop{SELECT DISTINCT} \textrm{ attribute}_1, \dotsc, \textrm{ attribute}_k\notag\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{FROM } \phi_{(i_1)}, \dotsc, \phi_{(i_n)}\notag\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{WHERE} \textrm{ some condition} \label{eq:sql-fo}\\
	& \;\mid \textrm{some table of arity $k$} \notag\\
	& \;\mid \phi_{(k)} \mathrel{\sqlop{ UNION }} \phi_{(k)}
		\mid \phi_{(k)} \mathrel{\sqlop{ EXCEPT }} \phi_{(k)}
		\mid \phi_{(k)} \mathrel{\sqlop{ INTERSECT }} \phi_{(k)}, \notag
\end{align}
where $i_1 + \dotsc + i_n = k$ and the condition after $\sqlop{WHERE}$
is a conjunction of equalities between attributes.
Dealing with the arity $k \in \N$ is required to ensure "eg" that the union 
is homogeneous---"ie" that all facts in the union have the same arity.%
\footnote{Also, the \textsf{DISTINCT} keyword is only necessary because SQL
has a multiset semantics rather than a set-based semantics…}

\begin{proposition}[Codd's theorem {\cite[\S~4]{Codd1972RelationalCompleteness}}]
	\!\footnote{Codd's theorem actually deals
	with \emph{relational algebra} rather than SQL.
	The equivalence between \emph{relational algebra} and the fragment
	\eqref{eq:sql-fo} of SQL is however straightforward.
	See also \cite[Theorem~5.4.6]{AbiteboulHullVianu1995Databases}.}
	\AP\label{prop:codd-thm}
	"First-order logic" over "$\sigma$-structures" with no "isolated vertices"
	is equally expressive to the SQL fragment defined in \eqref{eq:sql-fo}.
	Moreover, this equivalence is effective.
\end{proposition}

\begin{proof}[Proof sketch]
	\emph{Warning:} dealing with all the subtleties of the proof is actually
	somewhat tedious. Hence, we provide an \emph{informal} proof,
	which prioritizes intuition over formalism.

	Expressing a SQL query as a "first-order formula" is intuitive,
	by generalizing the idea given in \Cref{sec:intro-cq}:
	\begin{itemize}
		\item $\sqlop{UNION}$, $\sqlop{EXCEPT}$ AND $\sqlop{INTERSECT}$
			are interpreted as the union, set difference ("ie" $- \land (\neg -)$)
			and intersection;
		\item a table of arity $k$, modelled as a relation $\+R_{(k)}$,
			is encoded as the atomic formula
			\[
				\phi_{(k)}(x_1,\hdots,x_k) \defeq \+R_{(k)}(x_1,\hdots,x_k)
			\]
			with $k$ free variables which are all fresh;
		\item a query
			\begin{align*}
				& \sqlop{SELECT DISTINCT} \textrm{ attribute}_1, \dotsc, \textrm{ attribute}_k \\
				& \sqlop{FROM } \phi^1_{(i_1)}, \dotsc, \phi^n_{(i_n)} \\
				& \sqlop{WHERE} \theta 
			\end{align*}
			is encoded as
			\[
				\psi(y_1,\hdots,y_k) \defeq
				\exists \bar x.\;
				\phi^1_{(i_1)}(x^1_1,\dotsc,x^1_{i_1})
				\land \dotsc \land
				\phi^n_{(i_n)}(x^n_1,\dotsc,x^n_{i_n})
				\land \theta,
			\]
			with $y_1$, $\dotsc$, $y_k$ being the variable associated
			to the attributes---"eg" if $\textrm{attribute}_1$ is the
			third attribute of $\phi^2$, then $y_1 \defeq x^2_3$---
			and $\bar x$ is the tuple of all variables of the form $x^i_j$
			that are distinct from the $y_i$'s.
	\end{itemize}
	
	The converse encoding, "ie" from first-order logic to SQL queries,
	is a little more tricky:
	\begin{itemize}
		\item union is encoded with \sqlop{UNION},
			intersection and existential quantification with
			\sqlop{SELECT DISTINCT}-\sqlop{FROM}-\sqlop{WHERE};
		\item we encode negation using \sqlop{EXCEPT} and a SQL query
			that outputs every $k$-tuple of vertices of the "structure"---this query can
			be written as a big union of \sqlop{SELECT DISTINCT}-\sqlop{FROM}
			queries;
		\item lastly, universal quantification can then be obtained
			using the tautology
			\[\forall x.\; \phi(x) \equiv \neg\exists x.\; \neg \phi(x).\qedhere\]
	\end{itemize}
\end{proof}

A crucial ingredient that ensures the correctness of these encodings
is actually the fact that "relational databases" are encoded
as "relational structures" \textbf{with no "isolated variables"}.%
\footnote{The restriction of "first-order logic" to
"relational databases" is usually called \emph{relational calculus}.}
Take for instance the "first-order formula"
$\neg \textsc{Room}(x,y)$:
we expressed it in SQL as
\[
	\textrm{All pairs}
	\mathrel{\sqlop{ EXCEPT }}
	(\sqlop{SELECT DISTINCT } x, y \mathrel{\sqlop{ FROM }} \textsc{Room})\; 
\]
where `All pairs' is a query outputting all pairs in the database.
The equivalence, or more precisely the fact that the semantics
of the "first-order formula" over the "relational structure"
is included in the semantics of the SQL query over the "relational structure", is
precisely permitted by the lack of "isolated vertices" in
the "structure": for more details, we refer the reader 
to the term ``active domain'' in \cite{AbiteboulHullVianu1995Databases}.%
\footnote{The same query is actually a good example of why there is no built-in
negation in SQL, even though it would not change its expressiveness: it
is actually very hard to image a situation where
knowing that `Xavier Dolan' is not the id of a room with capacity `2025-03-28 14:00'
would be useful…}

The expressiveness of this fragment of SQL however comes to the cost
of computational efficiency.

\begin{proposition}[Folklore]
	Given a "first-order formula" $\phi(\bar x)$, a "relational structure" $\?D$
	with no "isolated vertices", and a tuple $\bar d$, deciding
	if $\bar d \in \semFO{\phi(\bar x)}{\?D}$
	is "PSpace"-complete.
\end{proposition}

\begin{proof}[Proof sketch]
	The upper bound can be proven by considering the naïve algorithm
	that recurses on the formula.
	The lower bound follows from a trivial reduction from
	the "quantified Boolean formula problem".
\end{proof}

Even worth, when turning to the \emph{static analysis} of these queries, 
the problems become undecidable. Given two (semantical) "queries" $\phi$ and $\psi$,
we say that they are "semantically equivalent"---implicitly
over "finite@@struct" "relational databases"---when for every "finite@@struct" "relational databases" $\?D$, we have $\?D \in \phi$ "iff" $\?D \in \phi'$.
This fact is denoted by \AP$\phi \intro*\semequiv \phi'$.

\begin{proposition}[Trakhtenbrot $\ast$ Databases, see "eg" {\cite[Theorem~6.3.1 \& Corollary~6.3.2]{AbiteboulHullVianu1995Databases}}]
	\!\footnote{This result is often incorrectly confused with
	"Trakhtenbrot's theorem", which deals with all "relational structures".
	However, the notion of "semantical equivalence" differs when considered
	over "relational databases" or all "relational structures".}
	\AP\label{prop:Trakhtenbrot-db}
	It is undecidable whether a
	"first-order formula" is satisfiable over finite "relational databases".
	In turn, validity and "semantical equivalence" are also undecidable.
\end{proposition}

In turn, it means that there is no hope to optimize a SQL query from the
fragment \eqref{eq:sql-fo}, in the sense of \Cref{sec:intro-existential}.%

\begin{corollary}[Folklore than is unfortunately often not mentionned, see "eg"
	{\cite[Remark~5.3]{AdlerWeyer2012TreeWidthFirstOrder}}]
	\label{coro:undecidability-minimization}
	Given a "first-order formula" $\phi$ and $k\in\N$, it is undecidable
	whether $\phi$ is "semantically equivalent" to a "formula@@FO" with at most $k$ variables.
\end{corollary}

\subsection{Conjunctive Queries to the Rescue}

The undecidability results of \Cref{prop:Trakhtenbrot-db,coro:undecidability-minimization},
together with the fact that queries occurring in practice---see \Cref{sec:intro-cq}---are
much simpler than the formulas occurring in the undecidability proof motivate
the study of well-behaved query fragments.

"Conjunctive queries" arise as either the fragment
\begin{align}
	\phi_{(k)}\; & \mathrel{{:}{:}{=}} \sqlop{SELECT DISTINCT} \textrm{ attribute}_1, \dotsc, \textrm{ attribute}_k\notag\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{FROM } \phi_{(i_1)}, \dotsc, \phi_{(i_n)}\label{eq:sql-cq}\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{WHERE} \textrm{ some condition} \notag\\
	& \;\mid \textrm{some table of arity $k$} \notag
\end{align}
of SQL, where, once again, $i_1 + \dotsc + i_n = k$ and the condition after $\sqlop{WHERE}$
is a conjunction of equalities between attributes.
From the proof of \Cref{prop:codd-thm} it actually follows that this fragment is exactly
as expressive as the fragment of "first-order logic", restricted to "relational databases",
generated by 
\begin{align}
	\phi \mathrel{{:}{:}{=}} \+R_{(k)}(x_1,\dotsc,x_k) \mid \phi \land \phi \mid \exists x.\; \phi,
	\label{eq:fo-cq}
\end{align}
where $\+R_{(k)}$ ranges over the "signature".

Now observe that, when dealing with the fragment \eqref{eq:fo-cq},
the "first-order formula" $(\exists x.\; \phi(x, \bar y)) \land \psi(\bar z)$
is equivalent to $\exists x'.\; (\phi(x', \bar y) \land \psi(\bar z))$
where $x'$ is any variable that occurs neither in $\bar y$ nor in $\bar z$.
For instance, we have 
\[
	(\exists x.\, \+P(x)) \land (\exists x.\, \exists y.\,\+R(x,y))
	\semequiv
	\exists z.\,\exists x.\, \exists y.\, \+P(z) \land \+R(x,y).
\]
This leads to a simple rewriting system that puts every formula from 
\eqref{eq:fo-cq} in so-called "prenex form".

\begin{proposition}[""Prenex form""]
	\AP\label{prop:prenex-form}
	Every formula from \eqref{eq:fo-cq} can be written in the form
	\begin{align}
		\exists \bar x.\, \bigwedge_{i=1}^n \+R^i_{(k_i)}(y^i_1,\dotsc,y^i_{k_i}).
		\label{eq:prenex-fo}
	\end{align}
\end{proposition}

\Cref{prop:prenex-form} has remarkable consequences.
Translating back the "formulas@@FO" in "prenex form" to 
SQL queries, it implies that the fragment \eqref{eq:sql-cq}
is no more expressive than its induction-free fragment
\begin{align}
	\phi_{(k)}\; & \mathrel{{:}{:}{=}} \sqlop{SELECT DISTINCT} \textrm{ attribute}_1, \dotsc, \textrm{ attribute}_k\notag\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{FROM } \textrm{table}_{(i_1)}, \dotsc, \textrm{table}_{(i_n)}\label{eq:sql-cq-bis}\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{WHERE} \textrm{ some condition}. \notag
\end{align}

Formally, we define a \AP"conjunctive query" to be
any "first-order formula" in "prenex form"---see \Cref{eq:prenex-fo}.
Recall that, as mentioned in \Cref{rk:prelim-formula-tuple},
we assume that "formulas" comes with a tuple of variables,
containing all free variables, potentially with repetition.
Hence, a \AP""conjunctive query"" over a "purely relational signature" $\sigma$,
or \reintro{CQ} for short, amounts to a finite set
of atomic formulas of the form $\+R_{(k)}(x_1,\hdots,x_k)$,
called ""atoms@@cq"", with $\+R_{(k)} \in \sigma$,
together with tuple of variables $\bar x$, called ""free variables@@cq""
or ""output variables@@cq"". The set of atoms is denoted conjunctively.
So, an example of "conjunctive query" is
\begin{align*}
	\gamma(\textsf{title}, \textsf{time}) \defeq\; 
	& \textsc{Movies}(\textsf{movie\_id}, \textsf{title}, \textsf{length}, \textsf{director}) \\
	& \land
	\textsc{Projections}(\textsf{movie\_id}, \textsf{room\_id}, \textsf{time}).
\end{align*} 
Semantically, it is interpreted as the "first-order formula" in "prenex form"
in which every variable that is not an "output variable" is quantified existentially,
giving in our case
\begin{align*}
	\gamma(\textsf{title}, \textsf{time}) \defeq\; 
	& \exists \textsf{movie\_id}.\, 
	\exists \textsf{length}.\, 
	\exists \textsf{director}.\,
	\exists \textsf{room\_id}.\, \\
	& \hphantom{\land~} \textsc{Movies}(\textsf{movie\_id}, \textsf{title}, \textsf{length}, \textsf{director}) \\
	& \land
	\textsc{Projections}(\textsf{movie\_id}, \textsf{room\_id}, \textsf{time}).
\end{align*} 

Interestingly, the semantics of "conjunctive queries" can be described using "homomorphisms",
via the theory of \emph{duality}.
\begin{definition}
	The "canonical database" associated to a "conjunctive query"
	\[
		\gamma(\bar x) = \bigwedge_{i=1}^n \+R^i_{(k_i)}(y^i_1,\dotsc,y^i_{k_i})
	\]
	over the "purely relational signature" $\sigma$ is the "pointed relational database"
	over $\sigma$ with tuple $\bar x$ and whose facts are
	$\+R^i_{(k_i)}(y^i_1,\dotsc,y^i_{k_i})$ for $i \in \intInt{1,n}$.
\end{definition}
We say that a "conjunctive query" is ""Boolean@@cq"" when it has no "output variables".
In this case, its "canonical database" is not only a "pointed relational database" but
in fact a "relational database".

\begin{proposition}[""Duality""]
	\AP\label{prop:duality}
	Let $\gamma(\bar x)$ be a "conjunctive query",
	and let $\tup{\?G, \bar x}$ denote its "canonical database".%
	\footnote{We denote the "canonical database" using the Roman
	uppercase associated with the Greek letter used to denote
	the query.}
	For any "pointed relational database" $\tup{\?D, \bar d}$,
	we have
	\[
		\bar d \in \semFO{\gamma(\bar x)}{\?D}
		\qquad\text{"iff"}\qquad
		\tup{\?G, \bar x} \homto \tup{\?D, \bar d}.
	\]
\end{proposition}

\begin{proof}
	This follows from the definition of "homomorphisms" and
	the semantics of "first-order logic".
\end{proof}

Duality has \emph{many} consequences. First, the following evaluation problem
lies in "NP", as it can be encoded into a "homomorphism problem".
\decisionproblem{""Conjunctive Query Evaluation""}{
	A "signature" $\sigma$,
	a "conjunctive query" $\gamma(\bar x)$ over $\sigma$,
	and a "pointed relational $\sigma$-database" $\tup{\?D, \bar d}$.
}{
	Does $\bar d \in \semFO{\gamma(\bar x)}{\?D}$?
}
For "Boolean conjunctive queries", both tuples are empty, and so
this amounts to asking whether the query is true on the "database@@rel".
More importantly, "duality" has the consequence that
"semantical equivalence", as well as the finer notion of "containment",
are decidable for "CQs".

Given two "queries@@sem" $\gamma(\bar x)$ and $\gamma'(\bar x')$,
we say that $\gamma(\bar x)$ is ""contained"" in $\gamma'(\bar x')$
whenever (1) $\bar x$ and $\bar x'$ have the same arity, and (2)
$\semFO{\gamma(\bar x)}{\?D} \subseteq \semFO{\gamma'(\bar x')}{\?D}$
for every "finite@@struct" "relational database" $\?D$. This is denoted by
$\gamma(\bar x) \intro*\contained \gamma'(\bar x')$; the notion
of "containment" is also known as \emph{entailment} of \emph{logical implication}.
Clearly, "semantical equivalence" can be obtained as the symmetric
closure of "containment".

\begin{proposition}
	\!\footnote{In fact, another consequence of "duality" is that
	the quantification over "finite@@struct" "relational databases"
	in the definition of "containment" can be equivalently replaced
	by a quantification over "finite structures", or even over all "structures"!}
	\AP\label{prop:containment-hom}
	Let $\gamma(\bar x)$ and $\gamma'(\bar x')$ be two "CQs".
	The following are equivalent:
	\begin{enumerate}
		\item $\gamma(\bar x) \intro*\contained \gamma'(\bar x')$;
		\item $\tup{\?G, \bar x} \FOmodels \gamma'(\bar x')$;
		\item $\tup{\?G', \bar x'} \homto \tup{\?G, \bar x}$,
	\end{enumerate}
	where $\tup{\?G, \bar x}$ and $\tup{\?G', \bar x'}$ are the "canonical databases"
	of $\gamma(\bar x)$ and $\gamma'(\bar x')$, respectively.
\end{proposition}

\begin{proof}
	\proofcase{(1) $\Rightarrow$ (2).}
	By "duality", $\tup{\?G, \bar x}$ is a model of $\gamma(\bar x)$,
	and so, since this query is "contained" in $\gamma'(\bar x')$,
	it follows that $\tup{\?G, \bar x} \FOmodels \gamma'(\bar x')$.

	\proofcase{(2) $\Rightarrow$ (3).} By "duality".

	\proofcase{(3) $\Rightarrow$ (1).} Assume that
	$\tup{\?G', \bar x'} \homto \tup{\?G, \bar x}$,
	and let us prove that $\gamma(\bar x) \contained \gamma'(\bar x')$.
	Let $\tup{\?D, \bar d}$ be a "pointed relational database",
	and assume that $\tup{\?D, \bar d} \FOmodels \gamma(\bar x)$.
	By "duality", we get $\tup{\?G, \bar x} \homto \tup{\?D, \bar d}$,
	and by precomposing with any "homomorphism" witnessing
	that $\tup{\?G', \bar x'} \homto \tup{\?G, \bar x}$,
	we get that $\tup{\?G', \bar x} \homto \tup{\?D, \bar d}$.
	Once again, by "duality", this amounts to $\tup{\?D, \bar d} \FOmodels \gamma'(\bar x')$,
	which concludes the proof that $\gamma(\bar x) \contained \gamma'(\bar x')$.
\end{proof}

As a consequence of \Cref{prop:containment-hom}, "containment" (and hence "semantical equivalence") of "conjunctive queries" is decidable, and in fact is "NP"-complete.


\subsection{The Preordered Set of Conjunctive Queries}

\begin{marginfigure}
	\centering
	\includegraphics[width=\linewidth]{fig/escher/bound-of-union.jpg}
	\caption{\href{https://mcescher.com/gallery/most-popular/\#iLightbox[gallery\_image\_1]/23}{\emph{Bond of Union}}, M. C. Escher, \textcopyright~The M.C. Escher Company.}
\end{marginfigure}
"Duality" takes its name from the fact that \Cref{prop:containment-hom} can be simply rephrased as
``the preordered set of "conjunctive queries" over $\sigma$ ordered by
"containment" is \emph{dually isomorphic} to the preordered set of "relational databases"
over $\sigma$  order by the homomorphism ordering.'' Symbolically: 
\[
	\tup{\kl[CQ]{\textrm{CQ}_\sigma},\; \contained }
	\cong
	\tup{\kl[relational database]{\textrm{RelDb}_\sigma},\; \cohomto }.
\]
Naturally, to go from "relational databases" to "conjunctive queries",
we associate to any "pointed relational database" $\tup{\?G, \bar g}$
a ""canonical conjunctive query"" $\gamma(\bar g)$ with one atom "atom"
$\+R_{(k)}(x_1,\hdots,x_k)$ for every "hyperedge" $\tup{x_1,\hdots,x_k} \in \+R_{(k)}(\?G)$.
This map is precisely the inverse of the construction defining "canonical databases".

This dual isomorphism has many consequences: essentially every theory that deals with
"relational databases" can be applied to study "conjunctive queries"!

\begin{corollary}[{of "duality" and \Cref{prop:equiv-core-isomorphic}}]
	Two "conjunctive queries" are "semantically equivalent" "iff"
	the "core" of their "canonical database" are "isomorphic".
\end{corollary}

\paragraph*{Graphical depiction of the preordered set of relational databases and conjunctive queries.}
Note that for each "conjunctive query" $\gamma(\bar x)$, the class of
"pointed relational databases" $\tup{\?D, \bar d}$ satisfying the query
is \AP""closed under homomorphisms"", "ie"
\[
	\text{if}\quad \tup{\?D, \bar d} \FOmodels \gamma(\bar x)
	\quad\text{and}\quad \tup{\?D, \bar d} \homto \tup{\?D', \bar d'}
	\quad\text{then}\quad \tup{\?D', \bar d'} \FOmodels \gamma(\bar x).
\]
We represent the preordered set of "relational databases" ordered by $\homto$ as follows:
each equivalence class of "homorphically equivalent" "relational databases" is
represented by a single point. In other words, points are in one-to-one correspondence
with "cores". Then, we represent a point $\core{\?G}$ below another point $\core{\?D}$
whenever $\core{\?G} \homto \core{\?D}$.
For "Boolean queries", this ordering%
\footnote{Formally, from the preordering over "relational databases" we obtained a partial
order over the quotient of "relational databases" by the equivalence class induced by $\homto$,
which happens to be partially ordered set of "cores". Hence, we will interchangeably
use to term \emph{preordering} or \emph{(partial) ordering}.}
admits a unique minimal element, which is the empty database.
For "non-Boolean queries", the ``empty database'' does not exist---where would the constants live?---and there is one minimal element for each "predicate" $\+R_{(k)}$,
consisting of the "relational database" with a single fact
$\+R_{(k)}(x_1,\hdots,x_k)$.%
\footnote{It is important that all vertices are disjoint!
Indeed, while we do have $\+R_{(k)}(x_1,\hdots,x_k) \homto \+R_{(k)}(x,\hdots,x)$,
there is no "homomorphism" going the other way.}
There is always a unique maximal element: the "database@@rel" with
a unique vertex $x$ and such that $\+R_{(k)}(x,\dotsc,x)$ holds for
every $\+R_{(k)} \in \sigma$.

We now prove that this poset has a non-trivial structure, assuming that the "signature"
is itself non-trivial.

\begin{proposition}
	Assume that $\sigma$ contains at least one symbol of arity at least 2,
	then the poset of "relational structures"
	admits infinite chains, infinite co-chains and infinite antichains.
\end{proposition}

\begin{proof}
	For the sake of simplicity, we assume that we actually have
	a binary predicate.%
	\footnote{This assumption is "wlog": we can encode the binary 
	relation used in these constructions into any $k$-ary
	relation provided that $k \geq 2$ by encoding $\+E(x,y)$
	as $\+R_{(k)}(x,y,\dotsc,y)$.}

	Clearly, "directed path" provide an infinite chain
	\[
		\pathGraph{1} \homto \pathGraph{2} \homto \cdots
			\homto \pathGraph{n} \homto \pathGraph{n+1} \homto \cdots.
	\]
	We now let $\?C_n$ ($n\in\Np$) denote the directed cycle with domain $\ZnZ{n}$
	and with an edge from $i$ to $j$ "iff" $i+1 = j$.\todo{figure}
	It is then routine to check that for $n,m\in\Np$, we have $\?C_n \homto \?C_m$
	"iff" $n$ is a multiple of $m$. In particular,%
	\footnote{In fact, we obtain a \emph{projective system}. We will discuss
	on projective limits in \todo{ref}.}
	we have
	\[
		\?C_1 \cohomto \?C_2 \cohomto \cdots \cohomto \?C_{2^n} \cohomto \?C_{2^{n+1}} \cohomto \cdots.
	\]
	Finally, $\tup{\?C_p}_{p \text{ prime}}$ is an infinite antichain.
\end{proof}

\begin{marginfigure}
	\centering
	\scalebox{.8}{
	\begin{tikzpicture}[
		font=\footnotesize
	]
		\node[vertex] (empty) at (0, 0) {};
		\node[right=2pt of empty] {$\emptyset$};

		\node[vertex] (p1) at (0, 0.7) {};
		\node[right=2pt of p1] {$\pathGraph{1}$};
		\node (p2) at (0, 1.4) {$\vdots$};
		\node[vertex] (p3) at (0, 2.1) {};
		\node[right=2pt of p3] {$\pathGraph{n}$};
		\node[vertex] (p4) at (0, 2.8) {};
		\node[right=2pt of p4] {$\pathGraph{n+1}$};
		\node (p5) at (0, 3.5) {$\vdots$};

		\node[vertex] (c1) at (0, 8.4) {};
		\node[left=2pt of c1] {$\?C_1$};
		\node[vertex] (c2) at (-0.425, 7.7) {};
		\node[left=2pt of c2] {$\?C_2$};
		\node (c4) at (-0.85, 7.0) {\rotatebox{-16}{$\vdots$}};
		\node[vertex] (c8) at (-1.275, 6.3) {};
		\node[left=2pt of c8] {$\?C_{2^n}$};
		\node[vertex] (c16) at (-1.7, 5.6) {};
		\node[left=2pt of c16] {$\?C_{2^{n+1}}$};
		\node (c32) at (-2.125, 4.9) {\rotatebox{-16}{$\vdots$}};

		\node[vertex] (c3) at (0.425, 7.7) {};
		\node[below right=2pt of c3] {$\?C_3$};
		\node (c9) at (0.85, 7.0) {\rotatebox{16}{$\vdots$}};
		\node[vertex] (c27) at (1.275, 6.3) {};
		\node[right=2pt of c27] {$\?C_{3^n}$};
		\node[vertex] (c81) at (1.7, 5.6) {};
		\node[right=2pt of c81] {$\?C_{3^{n+1}}$};
		\node (c243) at (2.125, 4.9) {\rotatebox{16}{$\vdots$}};

		\node[vertex] (c6) at (0, 7.0) {};
		\node[below right=2pt of c6] {$\?C_6$};
		\node (c36) at (0, 6.3) {$\vdots$};
		\node[vertex] (c216) at (0, 5.6) {};
		\node[below right=2pt of c216] {$\?C_{6^n}$};
		\node (c1296) at (0, 4.9) {$\vdots$};

		\node[vertex] (c5) at (1.275, 7.7) {};
		\node[below right=2pt of c5] {$\?C_5$};
		\node (c7) at (2.125, 7.7) {$\cdots$};

		% Edges: path chain
		\draw[edge] (empty) -- (p1);
		\draw[edge] (p1) -- (p2);
		\draw[edge] (p2) -- (p3);
		\draw[edge] (p3) -- (p4);
		\draw[edge] (p4) -- (p5);

		% Edges: cycle cochain
		\draw[edge] (c32) -- (c16);
		\draw[edge] (c16) -- (c8);
		\draw[edge] (c8) -- (c4);
		\draw[edge] (c4) -- (c2);
		\draw[edge] (c2) -- (c1);
		\draw[edge] (c243) -- (c81);
		\draw[edge] (c81) -- (c27);
		\draw[edge] (c27) -- (c9);
		\draw[edge] (c9) -- (c3);

		\draw[edge] (c3) -- (c1);
		\draw[edge] (c5) -- (c1);
		\draw[edge] (c6) -- (c2);
		\draw[edge] (c6) -- (c3);
		\draw[edge] (c216) -- (c36);
		\draw[edge] (c36) -- (c6);
		\draw[edge] (c216) -- (c8);
		\draw[edge] (c216) -- (c27);

		\draw[edge] (p5) to[out=90,in=-101.25] (c32);
		\draw[edge] (p5) to[out=90,in=-78.75] (c243);
		\draw[edge] (p5) -- (c1296);
	\end{tikzpicture}
	}
	\caption{\AP\label{fig:poset-reldb} The poset of "relational databases" over a "signature"
	containing at least one binary "predicate".}
\end{marginfigure}


\begin{remark}
	À propos "relational databases" "vs" "relational structures",
	these posets actually only marginally differ 
	since a "relational structure" is always "homomorphically equivalent"
	to the structure in which we removed "isolated vertices" that are not constants.
	The main difference is hence that "pointed relational structures" always 
	have a unique minimal element, which is the "structure" with a single
	vertex and no "hyperedge".
\end{remark}

The \AP""disjoint conjunction"" \AP$\intro*\disconj$ of two "CRPQs" consists of
the conjunction of the queries, up to renaming so that their variable sets are disjoint.



\begin{itemize}
	\item combined complexity / data complexity
	\item duality w/ table of equivalence (vertex <-> variable ; disjoint union <-> disjoint conjunctions)
	\itemAP $\intro*\underlying{\gamma}$ and ""underlying graph""
	\itemAP ""equality atom""
	\itemAP ""evaluation map@@cq"" (explain why notion is necessary by pointing to "evaluation map" for CRPQs)
	\itemAP ""disjunct""
	\itemAP ""conjunctive query evaluation""
\end{itemize}

\subsection{Static Analysis of Conjunctive Queries}

\subsection{Intermezzo: Parametrized Complexity Classes}

\begin{itemize}
	\itemAP ""FPT""
	\itemAP ""W1""
	\itemAP ""XP""
\end{itemize}

\subsection{Beyond Conjunctive Queries}