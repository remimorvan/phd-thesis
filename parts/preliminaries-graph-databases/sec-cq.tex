\section{Relational Databases}

\subsection{SQL and First-Order Logic}

The most common model of databases is by far that of "relational databases",
in which data is stored in \emph{tables}: an example is depicted
in \Cref{fig:relational-database-cinema}.

\begin{table}
	\centering%
	\input{tikz/intro/relational-database-cinema.tex}
	\caption{
		\AP\label{fig:relational-database-cinema}
		A "relational database" consisting of three tables, representing data
		stored by a cinema. (Replica of \Cref{fig:example-db-as-rel}.)
	}
\end{table}

Formally, a \AP""relational database"" $\?D$ over a "purely relational signature" $\sigma$
consists of, for each "predicate" $\+R$ of arity $k$ in $\sigma$,
a $k$-ary relation $\+R_{(k)}(\?D)$.%
\footnote{It is often asked that at least one $\+R_{(k)}(\?D)$ is non-empty.
Whether this condition is imposed does change the theory---for instance the "first-order sentences"
that are valid over all non-empty structures is a strict subset of
those valid over all (possible empty) structures.
However, this condition is mostly required for historical reasons,
and whether the databases are allowed to be non-empty
will be of little importance for the query languages we will consider.}
Each tuple of some relation $\+R_{(k)}(\?D)$ is called a \emph{fact}.
From a practical perspective, relations model the tables,
while each fact correspond to some row: for 
instance the database of \Cref{fig:relational-database-cinema}
has three relations and twelve facts.%
\footnote{Many variations on the definition above exists:
for instance the columns of the table are often given a name (called \emph{attribute}),
see "eg" \cite[\S\!\S~3.1--3.2]{AbiteboulHullVianu1995Databases}.
This is usually done to make the syntax of relational algebra for readable,
however this is only syntactic sugar \cite[Proposition~5.1.2]{AbiteboulHullVianu1995Databases}.}

Naturally, each "relational database" yields a "$\sigma$-structure" whose
domain is the set of elements occurring in some fact of the database.
This structure has the property that each vertex belongs to some "hyperedge":
in other words, it has no \AP""isolated vertices"".
This mapping is in fact one-to-one: "relational databases" over $\sigma$
are in bijection with "$\sigma$-structures" with no "isolated vertices".

As mentioned in \Cref{ch:intro}, from a theoretical perspective,
a very natural way of querying these "structures"
is "via" "first-order logic". Remarkably, it is exactly as expressive 
as the fragment of SQL consisting of queries generated by
\begin{align}
	\phi_{(k)}\; & \mathrel{{:}{:}{=}} \sqlop{SELECT DISTINCT} \textrm{ attribute}_1, \dotsc, \textrm{ attribute}_k\notag\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{FROM } \phi_{(i_1)}, \dotsc, \phi_{(i_n)}\notag\\
	& \hphantom{\mathrel{{:}{:}{=}}} \sqlop{WHERE} \textrm{ some condition} \label{eq:sql-fo}\\
	& \;\mid \textrm{some table of arity $k$} \notag\\
	& \;\mid \phi_{(k)} \mathrel{\sqlop{ UNION }} \phi_{(k)}
		\mid \phi_{(k)} \mathrel{\sqlop{ EXCEPT }} \phi_{(k)}
		\mid \phi_{(k)} \mathrel{\sqlop{ INTERSECT }} \phi_{(k)}, \notag
\end{align}
where $i_1 + \dotsc + i_n = k$ and the condition after $\sqlop{WHERE}$
is a conjunction of equalities between attributes.
Dealing with the arity $k \in \N$ is required to ensure "eg" that the union 
is homogeneous---"ie" that all facts in the union have the same arity.%
\footnote{Also, the \textsf{DISTINCT} keyword is only necessary because SQL
has a multiset semantics rather than a set-based semantics…}

\begin{proposition}[Codd's theorem {\cite[\S~4]{Codd1972RelationalCompleteness}}]
	\!\footnote{Codd's theorem actually deals
	with \emph{relational algebra} rather than SQL.
	The equivalence between \emph{relational algebra} and the fragment
	\eqref{eq:sql-fo} of SQL is however straightforward.
	See also \cite[Theorem~5.4.6]{AbiteboulHullVianu1995Databases}.}
	"First-order logic" over "$\sigma$-structures" with no "isolated vertices"
	is equally expressive to the SQL fragment defined in \eqref{eq:sql-fo}.
	Moreover, this equivalence is effective.
\end{proposition}

\begin{proof}[Proof sketch]
	\emph{Warning:} dealing with all the subtleties of the proof is actually
	somewhat tedious. Hence, we provide an \emph{informal} proof,
	which prioritizes intuition over formalism.

	Expressing a SQL query as a "first-order formula" is intuitive,
	by generalizing the idea given in \Cref{sec:intro-cq}:
	\begin{itemize}
		\item $\sqlop{UNION}$, $\sqlop{EXCEPT}$ AND $\sqlop{INTERSECT}$
			are interpreted as the union, set difference ("ie" $- \land (\neg -)$)
			and intersection;
		\item a table of arity $k$, modelled as a relation $\+R_{(k)}$,
			is encoded as the atomic formula
			\[
				\phi_{(k)}(x_1,\hdots,x_k) \defeq \+R_{(k)}(x_1,\hdots,x_k)
			\]
			with $k$ free variables which are all fresh;
		\item a query
			\begin{align*}
				& \sqlop{SELECT DISTINCT} \textrm{ attribute}_1, \dotsc, \textrm{ attribute}_k \\
				& \sqlop{FROM } \phi^1_{(i_1)}, \dotsc, \phi^n_{(i_n)} \\
				& \sqlop{WHERE} \theta 
			\end{align*}
			is encoded as
			\[
				\psi(y_1,\hdots,y_k) \defeq
				\exists \bar x.\;
				\phi^1_{(i_1)}(x^1_1,\dotsc,x^1_{i_1})
				\land \dotsc \land
				\phi^n_{(i_n)}(x^n_1,\dotsc,x^n_{i_n})
				\land \theta,
			\]
			with $y_1$, $\dotsc$, $y_k$ being the variable associated
			to the attributes---"eg" if $\textrm{attribute}_1$ is the
			third attribute of $\phi^2$, then $y_1 \defeq x^2_3$---
			and $\bar x$ is the tuple of all variables of the form $x^i_j$
			that are distinct from the $y_i$'s.
	\end{itemize}
	
	The converse encoding, "ie" from first-order logic to SQL queries,
	is a little more tricky:
	\begin{itemize}
		\item union is encoded with \sqlop{UNION},
			intersection and existential quantification with
			\sqlop{SELECT DISTINCT}-\sqlop{FROM}-\sqlop{WHERE};
		\item we encode negation using \sqlop{EXCEPT} and a SQL query
			that outputs every $k$-tuple of vertices of the "structure"---this query can
			be written as a big union of \sqlop{SELECT DISTINCT}-\sqlop{FROM}
			queries;
		\item lastly, universal quantification can then be obtained
			using the tautology
			\[\forall x.\; \phi(x) \equiv \neg\exists x.\; \neg \phi(x).\qedhere\]
	\end{itemize}
\end{proof}

A crucial ingredient that ensures the correctness of these encodings
is actually the fact that "relational databases" are encoded
as "relational structures" \textbf{with no "isolated variables"}.%
\footnote{The restriction of "first-order logic" to
"relational databases" is usually called \emph{relational calculus}.}
Take for instance the "first-order formula"
$\neg \textsc{Room}(x,y)$:
we expressed it in SQL as
\[
	\textrm{all pairs}
	\mathrel{\sqlop{ EXCEPT }}
	(\sqlop{SELECT DISTINCT } x, y \mathrel{\sqlop{ FROM }} \textsc{Room})\; 
\]
where `all pairs' is a query outputting all pairs in the database.
The equivalence, or more precisely the fact that the semantics
of the "first-order formula" over the "relational structure"
is included in the semantics of the SQL query over the "relational structure", is
precisely permitted by the lack of "isolated vertices" in
the "structure": for more details, we refer the reader 
to the term ``active domain'' in \cite{AbiteboulHullVianu1995Databases}.%
\footnote{The same query is actually a good example of why there is no built-in
negation in SQL, even though it would not change its expressiveness: it
is actually very hard to image a situation where
knowing that `Xavier Dolan' is not the id of a room with capacity `2025-03-28 14:00'
would be useful…}

The expressiveness of this fragment of SQL however comes to the cost
of computational efficiency.

\begin{proposition}[Folklore]
	Given a "first-order formula" $\phi(\bar x)$, a "relational structure" $\?D$
	with no "isolated vertices", and a tuple $\bar d$, deciding
	if $\bar d \in \semFO{\phi(\bar x)}{\?D}$
	is "PSpace"-complete.
\end{proposition}

\begin{proof}[Proof sketch]
	The upper bound can be proven by considering the naïve algorithm
	that recurses on the formula.
	The lower bound follows from a trivial reduction from
	the "quantified Boolean formula problem".
\end{proof}

Even worth, when turning to the \emph{static analysis} of these queries, 
the problems become undecidable. Given two (semantical) "queries" $\phi$ and $\psi$,
we say that they are "semantically equivalent"---implicitly
over "finite@@struct" "relational databases"---when for every "finite@@struct" "relational databases" $\?D$, we have $\?D \in \phi$ "iff" $\?D \in \phi'$.
This fact is denoted by \AP$\phi \intro*\semequiv \phi'$.

\begin{proposition}[Trakhtenbrot $\ast$ Databases, see "eg" {\cite[Corollary~6.3.2]{AbiteboulHullVianu1995Databases}}]
	\!\footnote{This result is often incorrectly confused with
	"Trakhtenbrot's theorem", which deals with all "relational structures".
	However, the notion of "semantical equivalence" differs when considered
	over "relational databases" or all "relational structures".}
	\AP\label{prop:Trakhtenbrot-db}
	It is undecidable whether two "first-order formulas"
	are "semantically equivalent" over all "relational databases".
\end{proposition}

In turn, it means that there is no hope to optimize a SQL query from the
fragment \eqref{eq:sql-fo}, in the sense of \Cref{sec:intro-existential}.%

\begin{proposition}[Folklore than is unfortunately often not mentionned, see "eg"
	{\cite[Remark~5.3]{AdlerWeyer2012TreeWidthFirstOrder}}]
	Given a "first-order formula" $\phi$ and $k\in\N$, it is undecidable
	whether $\phi$ is "semantically equivalent" to a "formula" with at most $k$ variables.
\end{proposition}


\subsection{Conjunctive Queries to the Rescue}



\begin{itemize}
	\item duality w/ table of equivalence (vertex <-> variable ; disjoint union <-> disjoint conjunctions)
	\itemAP $\intro*\underlying{\gamma}$ and ""underlying graph""
	\itemAP ""equality atom""
	\itemAP ""evaluation map@@cq"" (explain why notion is necessary by pointing to "evaluation map" for CRPQs)
	\itemAP ""disjunct""
	\itemAP ""conjunctive query evaluation""
\end{itemize}

\subsection{Static Analysis of Conjunctive Queries}

\subsection{Intermezzo: Parametrized Complexity Classes}

\begin{itemize}
	\itemAP ""FPT""
	\itemAP ""W1""
	\itemAP ""XP""
\end{itemize}

\subsection{Beyond Conjunctive Queries}